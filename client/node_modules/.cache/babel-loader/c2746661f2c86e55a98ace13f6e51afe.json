{"ast":null,"code":"/**\n * @file postscribe\n * @description Asynchronously write javascript, even with document.write.\n * @version v2.0.8\n * @see {@link https://krux.github.io/postscribe}\n * @license MIT\n * @author Derek Brans\n * @copyright 2016 Krux Digital, Inc\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"postscribe\"] = factory();else root[\"postscribe\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      var _postscribe = __webpack_require__(1);\n\n      var _postscribe2 = _interopRequireDefault(_postscribe);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          'default': obj\n        };\n      }\n\n      module.exports = _postscribe2['default'];\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      exports['default'] = postscribe;\n\n      var _writeStream = __webpack_require__(2);\n\n      var _writeStream2 = _interopRequireDefault(_writeStream);\n\n      var _utils = __webpack_require__(4);\n\n      var utils = _interopRequireWildcard(_utils);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj['default'] = obj;\n          return newObj;\n        }\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          'default': obj\n        };\n      }\n      /**\n       * A function that intentionally does nothing.\n       */\n\n\n      function doNothing() {}\n      /**\n       * Available options and defaults.\n       *\n       * @type {Object}\n       */\n\n\n      var OPTIONS = {\n        /**\n         * Called when an async script has loaded.\n         */\n        afterAsync: doNothing,\n\n        /**\n         * Called immediately before removing from the write queue.\n         */\n        afterDequeue: doNothing,\n\n        /**\n         * Called sync after a stream's first thread release.\n         */\n        afterStreamStart: doNothing,\n\n        /**\n         * Called after writing buffered document.write calls.\n         */\n        afterWrite: doNothing,\n\n        /**\n         * Allows disabling the autoFix feature of prescribe\n         */\n        autoFix: true,\n\n        /**\n         * Called immediately before adding to the write queue.\n         */\n        beforeEnqueue: doNothing,\n\n        /**\n         * Called before writing a token.\n         *\n         * @param {Object} tok The token\n         */\n        beforeWriteToken: function beforeWriteToken(tok) {\n          return tok;\n        },\n\n        /**\n         * Called before writing buffered document.write calls.\n         *\n         * @param {String} str The string\n         */\n        beforeWrite: function beforeWrite(str) {\n          return str;\n        },\n\n        /**\n         * Called when evaluation is finished.\n         */\n        done: doNothing,\n\n        /**\n         * Called when a write results in an error.\n         *\n         * @param {Error} e The error\n         */\n        error: function error(e) {\n          throw new Error(e.msg);\n        },\n\n        /**\n         * Whether to let scripts w/ async attribute set fall out of the queue.\n         */\n        releaseAsync: false\n      };\n      var nextId = 0;\n      var queue = [];\n      var active = null;\n\n      function nextStream() {\n        var args = queue.shift();\n\n        if (args) {\n          var options = utils.last(args);\n          options.afterDequeue();\n          args.stream = runStream.apply(undefined, args);\n          options.afterStreamStart();\n        }\n      }\n\n      function runStream(el, html, options) {\n        active = new _writeStream2['default'](el, options); // Identify this stream.\n\n        active.id = nextId++;\n        active.name = options.name || active.id;\n        postscribe.streams[active.name] = active; // Override document.write.\n\n        var doc = el.ownerDocument;\n        var stash = {\n          close: doc.close,\n          open: doc.open,\n          write: doc.write,\n          writeln: doc.writeln\n        };\n\n        function _write(str) {\n          str = options.beforeWrite(str);\n          active.write(str);\n          options.afterWrite(str);\n        }\n\n        _extends(doc, {\n          close: doNothing,\n          open: doNothing,\n          write: function write() {\n            for (var _len = arguments.length, str = Array(_len), _key = 0; _key < _len; _key++) {\n              str[_key] = arguments[_key];\n            }\n\n            return _write(str.join(''));\n          },\n          writeln: function writeln() {\n            for (var _len2 = arguments.length, str = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              str[_key2] = arguments[_key2];\n            }\n\n            return _write(str.join('') + '\\n');\n          }\n        }); // Override window.onerror\n\n\n        var oldOnError = active.win.onerror || doNothing; // This works together with the try/catch around WriteStream::insertScript\n        // In modern browsers, exceptions in tag scripts go directly to top level\n\n        active.win.onerror = function (msg, url, line) {\n          options.error({\n            msg: msg + ' - ' + url + ': ' + line\n          });\n          oldOnError.apply(active.win, [msg, url, line]);\n        }; // Write to the stream\n\n\n        active.write(html, function () {\n          // restore document.write\n          _extends(doc, stash); // restore window.onerror\n\n\n          active.win.onerror = oldOnError;\n          options.done();\n          active = null;\n          nextStream();\n        });\n        return active;\n      }\n\n      function postscribe(el, html, options) {\n        if (utils.isFunction(options)) {\n          options = {\n            done: options\n          };\n        } else if (options === 'clear') {\n          queue = [];\n          active = null;\n          nextId = 0;\n          return;\n        }\n\n        options = utils.defaults(options, OPTIONS); // id selector\n\n        if (/^#/.test(el)) {\n          el = window.document.getElementById(el.substr(1));\n        } else {\n          el = el.jquery ? el[0] : el;\n        }\n\n        var args = [el, html, options];\n        el.postscribe = {\n          cancel: function cancel() {\n            if (args.stream) {\n              args.stream.abort();\n            } else {\n              args[1] = doNothing;\n            }\n          }\n        };\n        options.beforeEnqueue(args);\n        queue.push(args);\n\n        if (!active) {\n          nextStream();\n        }\n\n        return el.postscribe;\n      }\n\n      _extends(postscribe, {\n        // Streams by name.\n        streams: {},\n        // Queue of streams.\n        queue: queue,\n        // Expose internal classes.\n        WriteStream: _writeStream2['default']\n      });\n      /***/\n\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      var _prescribe = __webpack_require__(3);\n\n      var _prescribe2 = _interopRequireDefault(_prescribe);\n\n      var _utils = __webpack_require__(4);\n\n      var utils = _interopRequireWildcard(_utils);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj['default'] = obj;\n          return newObj;\n        }\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          'default': obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Turn on to debug how each chunk affected the DOM.\n       * @type {boolean}\n       */\n\n\n      var DEBUG_CHUNK = false;\n      /**\n       * Prefix for data attributes on DOM elements.\n       * @type {string}\n       */\n\n      var BASEATTR = 'data-ps-';\n      /**\n       * ID for the style proxy\n       * @type {string}\n       */\n\n      var PROXY_STYLE = 'ps-style';\n      /**\n       * ID for the script proxy\n       * @type {string}\n       */\n\n      var PROXY_SCRIPT = 'ps-script';\n      /**\n       * Get data attributes\n       *\n       * @param {Object} el The DOM element.\n       * @param {String} name The attribute name.\n       * @returns {String}\n       */\n\n      function getData(el, name) {\n        var attr = BASEATTR + name;\n        var val = el.getAttribute(attr); // IE 8 returns a number if it's a number\n\n        return !utils.existy(val) ? val : String(val);\n      }\n      /**\n       * Set data attributes\n       *\n       * @param {Object} el The DOM element.\n       * @param {String} name The attribute name.\n       * @param {null|*} value The attribute value.\n       */\n\n\n      function setData(el, name) {\n        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var attr = BASEATTR + name;\n\n        if (utils.existy(value) && value !== '') {\n          el.setAttribute(attr, value);\n        } else {\n          el.removeAttribute(attr);\n        }\n      }\n      /**\n       * Stream static html to an element, where \"static html\" denotes \"html\n       * without scripts\".\n       *\n       * This class maintains a *history of writes devoid of any attributes* or\n       * \"proxy history\".\n       *\n       * Injecting the proxy history into a temporary div has no side-effects,\n       * other than to create proxy elements for previously written elements.\n       *\n       * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to\n       * `proxy_history + staticHtml`.\n       * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes\n       * beside or inside of proxy elements), reflects the DOM structure that would\n       * have resulted if all writes had been squashed into a single write.\n       *\n       * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,\n       * `node` is appended to the corresponding *real* element within the DOM.\n       *\n       * Proxy elements are mapped to *actual* elements in the DOM by injecting a\n       * `data-id` attribute into each start tag in `staticHtml`.\n       *\n       */\n\n\n      var WriteStream = function () {\n        /**\n         * Constructor.\n         *\n         * @param {Object} root The root element\n         * @param {?Object} options The options\n         */\n        function WriteStream(root) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          _classCallCheck(this, WriteStream);\n\n          this.root = root;\n          this.options = options;\n          this.doc = root.ownerDocument;\n          this.win = this.doc.defaultView || this.doc.parentWindow;\n          this.parser = new _prescribe2['default']('', {\n            autoFix: options.autoFix\n          }); // Actual elements by id.\n\n          this.actuals = [root]; // Embodies the \"structure\" of what's been written so far,\n          // devoid of attributes.\n\n          this.proxyHistory = ''; // Create a proxy of the root element.\n\n          this.proxyRoot = this.doc.createElement(root.nodeName);\n          this.scriptStack = [];\n          this.writeQueue = [];\n          setData(this.proxyRoot, 'proxyof', 0);\n        }\n        /**\n         * Writes the given strings.\n         *\n         * @param {...String} str The strings to write\n         */\n\n\n        WriteStream.prototype.write = function write() {\n          var _writeQueue;\n\n          (_writeQueue = this.writeQueue).push.apply(_writeQueue, arguments); // Process writes\n          // When new script gets pushed or pending this will stop\n          // because new writeQueue gets pushed\n\n\n          while (!this.deferredRemote && this.writeQueue.length) {\n            var arg = this.writeQueue.shift();\n\n            if (utils.isFunction(arg)) {\n              this._callFunction(arg);\n            } else {\n              this._writeImpl(arg);\n            }\n          }\n        };\n        /**\n         * Calls the given function.\n         *\n         * @param {Function} fn The function to call\n         * @private\n         */\n\n\n        WriteStream.prototype._callFunction = function _callFunction(fn) {\n          var tok = {\n            type: 'function',\n            value: fn.name || fn.toString()\n          };\n\n          this._onScriptStart(tok);\n\n          fn.call(this.win, this.doc);\n\n          this._onScriptDone(tok);\n        };\n        /**\n         * The write implementation\n         *\n         * @param {String} html The HTML to write.\n         * @private\n         */\n\n\n        WriteStream.prototype._writeImpl = function _writeImpl(html) {\n          this.parser.append(html);\n          var tok = void 0;\n          var script = void 0;\n          var style = void 0;\n          var tokens = []; // stop if we see a script token\n\n          while ((tok = this.parser.readToken()) && !(script = utils.isScript(tok)) && !(style = utils.isStyle(tok))) {\n            tok = this.options.beforeWriteToken(tok);\n\n            if (tok) {\n              tokens.push(tok);\n            }\n          }\n\n          if (tokens.length > 0) {\n            this._writeStaticTokens(tokens);\n          }\n\n          if (script) {\n            this._handleScriptToken(tok);\n          }\n\n          if (style) {\n            this._handleStyleToken(tok);\n          }\n        };\n        /**\n         * Write contiguous non-script tokens (a chunk)\n         *\n         * @param {Array<Object>} tokens The tokens\n         * @returns {{tokens, raw, actual, proxy}|null}\n         * @private\n         */\n\n\n        WriteStream.prototype._writeStaticTokens = function _writeStaticTokens(tokens) {\n          var chunk = this._buildChunk(tokens);\n\n          if (!chunk.actual) {\n            // e.g., no tokens, or a noscript that got ignored\n            return null;\n          }\n\n          chunk.html = this.proxyHistory + chunk.actual;\n          this.proxyHistory += chunk.proxy;\n          this.proxyRoot.innerHTML = chunk.html;\n\n          if (DEBUG_CHUNK) {\n            chunk.proxyInnerHTML = this.proxyRoot.innerHTML;\n          }\n\n          this._walkChunk();\n\n          if (DEBUG_CHUNK) {\n            chunk.actualInnerHTML = this.root.innerHTML;\n          }\n\n          return chunk;\n        };\n        /**\n         * Build a chunk.\n         *\n         * @param {Array<Object>} tokens The tokens to use.\n         * @returns {{tokens: *, raw: string, actual: string, proxy: string}}\n         * @private\n         */\n\n\n        WriteStream.prototype._buildChunk = function _buildChunk(tokens) {\n          var nextId = this.actuals.length; // The raw html of this chunk.\n\n          var raw = []; // The html to create the nodes in the tokens (with id's injected).\n\n          var actual = []; // Html that can later be used to proxy the nodes in the tokens.\n\n          var proxy = [];\n          var len = tokens.length;\n\n          for (var i = 0; i < len; i++) {\n            var tok = tokens[i];\n            var tokenRaw = tok.toString();\n            raw.push(tokenRaw);\n\n            if (tok.attrs) {\n              // tok.attrs <==> startTag or atomicTag or cursor\n              // Ignore noscript tags. They are atomic, so we don't have to worry about children.\n              if (!/^noscript$/i.test(tok.tagName)) {\n                var id = nextId++; // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'\n\n                actual.push(tokenRaw.replace(/(\\/?>)/, ' ' + BASEATTR + 'id=' + id + ' $1')); // Don't proxy scripts: they have no bearing on DOM structure.\n\n                if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {\n                  // Proxy: strip all attributes and inject proxyof attribute\n                  proxy.push( // ignore atomic tags (e.g., style): they have no \"structural\" effect\n                  tok.type === 'atomicTag' ? '' : '<' + tok.tagName + ' ' + BASEATTR + 'proxyof=' + id + (tok.unary ? ' />' : '>'));\n                }\n              }\n            } else {\n              // Visit any other type of token\n              // Actual: append.\n              actual.push(tokenRaw); // Proxy: append endTags. Ignore everything else.\n\n              proxy.push(tok.type === 'endTag' ? tokenRaw : '');\n            }\n          }\n\n          return {\n            tokens: tokens,\n            raw: raw.join(''),\n            actual: actual.join(''),\n            proxy: proxy.join('')\n          };\n        };\n        /**\n         * Walk the chunks.\n         *\n         * @private\n         */\n\n\n        WriteStream.prototype._walkChunk = function _walkChunk() {\n          var node = void 0;\n          var stack = [this.proxyRoot]; // use shift/unshift so that children are walked in document order\n\n          while (utils.existy(node = stack.shift())) {\n            var isElement = node.nodeType === 1;\n            var isProxy = isElement && getData(node, 'proxyof'); // Ignore proxies\n\n            if (!isProxy) {\n              if (isElement) {\n                // New actual element: register it and remove the the id attr.\n                this.actuals[getData(node, 'id')] = node;\n                setData(node, 'id');\n              } // Is node's parent a proxy?\n\n\n              var parentIsProxyOf = node.parentNode && getData(node.parentNode, 'proxyof');\n\n              if (parentIsProxyOf) {\n                // Move node under actual parent.\n                this.actuals[parentIsProxyOf].appendChild(node);\n              }\n            } // prepend childNodes to stack\n\n\n            stack.unshift.apply(stack, utils.toArray(node.childNodes));\n          }\n        };\n        /**\n         * Handles Script tokens\n         *\n         * @param {Object} tok The token\n         */\n\n\n        WriteStream.prototype._handleScriptToken = function _handleScriptToken(tok) {\n          var _this = this;\n\n          var remainder = this.parser.clear();\n\n          if (remainder) {\n            // Write remainder immediately behind this script.\n            this.writeQueue.unshift(remainder);\n          }\n\n          tok.src = tok.attrs.src || tok.attrs.SRC;\n          tok = this.options.beforeWriteToken(tok);\n\n          if (!tok) {\n            // User has removed this token\n            return;\n          }\n\n          if (tok.src && this.scriptStack.length) {\n            // Defer this script until scriptStack is empty.\n            // Assumption 1: This script will not start executing until\n            // scriptStack is empty.\n            this.deferredRemote = tok;\n          } else {\n            this._onScriptStart(tok);\n          } // Put the script node in the DOM.\n\n\n          this._writeScriptToken(tok, function () {\n            _this._onScriptDone(tok);\n          });\n        };\n        /**\n         * Handles style tokens\n         *\n         * @param {Object} tok The token\n         */\n\n\n        WriteStream.prototype._handleStyleToken = function _handleStyleToken(tok) {\n          var remainder = this.parser.clear();\n\n          if (remainder) {\n            // Write remainder immediately behind this style.\n            this.writeQueue.unshift(remainder);\n          }\n\n          tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';\n          tok = this.options.beforeWriteToken(tok);\n\n          if (tok) {\n            // Put the style node in the DOM.\n            this._writeStyleToken(tok);\n          }\n\n          if (remainder) {\n            this.write();\n          }\n        };\n        /**\n         * Build a style and insert it into the DOM.\n         *\n         * @param {Object} tok The token\n         */\n\n\n        WriteStream.prototype._writeStyleToken = function _writeStyleToken(tok) {\n          var el = this._buildStyle(tok);\n\n          this._insertCursor(el, PROXY_STYLE); // Set content\n\n\n          if (tok.content) {\n            if (el.styleSheet && !el.sheet) {\n              el.styleSheet.cssText = tok.content;\n            } else {\n              el.appendChild(this.doc.createTextNode(tok.content));\n            }\n          }\n        };\n        /**\n         * Build a style element from an atomic style token.\n         *\n         * @param {Object} tok The token\n         * @returns {Element}\n         */\n\n\n        WriteStream.prototype._buildStyle = function _buildStyle(tok) {\n          var el = this.doc.createElement(tok.tagName);\n          el.setAttribute('type', tok.type); // Set attributes\n\n          utils.eachKey(tok.attrs, function (name, value) {\n            el.setAttribute(name, value);\n          });\n          return el;\n        };\n        /**\n         * Append a span to the stream. That span will act as a cursor\n         * (i.e. insertion point) for the element.\n         *\n         * @param {Object} el The element\n         * @param {string} which The type of proxy element\n         */\n\n\n        WriteStream.prototype._insertCursor = function _insertCursor(el, which) {\n          this._writeImpl('<span id=\"' + which + '\"/>');\n\n          var cursor = this.doc.getElementById(which);\n\n          if (cursor) {\n            cursor.parentNode.replaceChild(el, cursor);\n          }\n        };\n        /**\n         * Called when a script is started.\n         *\n         * @param {Object} tok The token\n         * @private\n         */\n\n\n        WriteStream.prototype._onScriptStart = function _onScriptStart(tok) {\n          tok.outerWrites = this.writeQueue;\n          this.writeQueue = [];\n          this.scriptStack.unshift(tok);\n        };\n        /**\n         * Called when a script is done.\n         *\n         * @param {Object} tok The token\n         * @private\n         */\n\n\n        WriteStream.prototype._onScriptDone = function _onScriptDone(tok) {\n          // Pop script and check nesting.\n          if (tok !== this.scriptStack[0]) {\n            this.options.error({\n              msg: 'Bad script nesting or script finished twice'\n            });\n            return;\n          }\n\n          this.scriptStack.shift(); // Append outer writes to queue and process them.\n\n          this.write.apply(this, tok.outerWrites); // Check for pending remote\n          // Assumption 2: if remote_script1 writes remote_script2 then\n          // the we notice remote_script1 finishes before remote_script2 starts.\n          // I think this is equivalent to assumption 1\n\n          if (!this.scriptStack.length && this.deferredRemote) {\n            this._onScriptStart(this.deferredRemote);\n\n            this.deferredRemote = null;\n          }\n        };\n        /**\n         * Build a script and insert it into the DOM.\n         * Done is called once script has executed.\n         *\n         * @param {Object} tok The token\n         * @param {Function} done The callback when complete\n         */\n\n\n        WriteStream.prototype._writeScriptToken = function _writeScriptToken(tok, done) {\n          var el = this._buildScript(tok);\n\n          var asyncRelease = this._shouldRelease(el);\n\n          var afterAsync = this.options.afterAsync;\n\n          if (tok.src) {\n            // Fix for attribute \"SRC\" (capitalized). IE does not recognize it.\n            el.src = tok.src;\n\n            this._scriptLoadHandler(el, !asyncRelease ? function () {\n              done();\n              afterAsync();\n            } : afterAsync);\n          }\n\n          try {\n            this._insertCursor(el, PROXY_SCRIPT);\n\n            if (!el.src || asyncRelease) {\n              done();\n            }\n          } catch (e) {\n            this.options.error(e);\n            done();\n          }\n        };\n        /**\n         * Build a script element from an atomic script token.\n         *\n         * @param {Object} tok The token\n         * @returns {Element}\n         */\n\n\n        WriteStream.prototype._buildScript = function _buildScript(tok) {\n          var el = this.doc.createElement(tok.tagName); // Set attributes\n\n          utils.eachKey(tok.attrs, function (name, value) {\n            el.setAttribute(name, value);\n          }); // Set content\n\n          if (tok.content) {\n            el.text = tok.content;\n          }\n\n          return el;\n        };\n        /**\n         * Setup the script load handler on an element.\n         *\n         * @param {Object} el The element\n         * @param {Function} done The callback\n         * @private\n         */\n\n\n        WriteStream.prototype._scriptLoadHandler = function _scriptLoadHandler(el, done) {\n          function cleanup() {\n            el = el.onload = el.onreadystatechange = el.onerror = null;\n          }\n\n          var error = this.options.error;\n\n          function success() {\n            cleanup();\n\n            if (done != null) {\n              done();\n            }\n\n            done = null;\n          }\n\n          function failure(err) {\n            cleanup();\n            error(err);\n\n            if (done != null) {\n              done();\n            }\n\n            done = null;\n          }\n\n          function reattachEventListener(el, evt) {\n            var handler = el['on' + evt];\n\n            if (handler != null) {\n              el['_on' + evt] = handler;\n            }\n          }\n\n          reattachEventListener(el, 'load');\n          reattachEventListener(el, 'error');\n\n          _extends(el, {\n            onload: function onload() {\n              if (el._onload) {\n                try {\n                  el._onload.apply(this, Array.prototype.slice.call(arguments, 0));\n                } catch (err) {\n                  failure({\n                    msg: 'onload handler failed ' + err + ' @ ' + el.src\n                  });\n                }\n              }\n\n              success();\n            },\n            onerror: function onerror() {\n              if (el._onerror) {\n                try {\n                  el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));\n                } catch (err) {\n                  failure({\n                    msg: 'onerror handler failed ' + err + ' @ ' + el.src\n                  });\n                  return;\n                }\n              }\n\n              failure({\n                msg: 'remote script failed ' + el.src\n              });\n            },\n            onreadystatechange: function onreadystatechange() {\n              if (/^(loaded|complete)$/.test(el.readyState)) {\n                success();\n              }\n            }\n          });\n        };\n        /**\n         * Determines whether to release.\n         *\n         * @param {Object} el The element\n         * @returns {boolean}\n         * @private\n         */\n\n\n        WriteStream.prototype._shouldRelease = function _shouldRelease(el) {\n          var isScript = /^script$/i.test(el.nodeName);\n          return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));\n        };\n\n        return WriteStream;\n      }();\n\n      exports['default'] = WriteStream;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @file prescribe\n       * @description Tiny, forgiving HTML parser\n       * @version vundefined\n       * @see {@link https://github.com/krux/prescribe/}\n       * @license MIT\n       * @author Derek Brans\n       * @copyright 2016 Krux Digital, Inc\n       */\n      (function webpackUniversalModuleDefinition(root, factory) {\n        if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"Prescribe\"] = factory();else root[\"Prescribe\"] = factory();\n      })(this, function () {\n        return (\n          /******/\n          function (modules) {\n            // webpackBootstrap\n\n            /******/\n            // The module cache\n\n            /******/\n            var installedModules = {};\n            /******/\n            // The require function\n\n            /******/\n\n            function __webpack_require__(moduleId) {\n              /******/\n              // Check if module is in cache\n\n              /******/\n              if (installedModules[moduleId])\n                /******/\n                return installedModules[moduleId].exports;\n              /******/\n              // Create a new module (and put it into the cache)\n\n              /******/\n\n              var module = installedModules[moduleId] = {\n                /******/\n                exports: {},\n\n                /******/\n                id: moduleId,\n\n                /******/\n                loaded: false\n                /******/\n\n              };\n              /******/\n              // Execute the module function\n\n              /******/\n\n              modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n              /******/\n              // Flag the module as loaded\n\n              /******/\n\n              module.loaded = true;\n              /******/\n              // Return the exports of the module\n\n              /******/\n\n              return module.exports;\n              /******/\n            }\n            /******/\n            // expose the modules object (__webpack_modules__)\n\n            /******/\n\n\n            __webpack_require__.m = modules;\n            /******/\n            // expose the module cache\n\n            /******/\n\n            __webpack_require__.c = installedModules;\n            /******/\n            // __webpack_public_path__\n\n            /******/\n\n            __webpack_require__.p = \"\";\n            /******/\n            // Load entry module and return exports\n\n            /******/\n\n            return __webpack_require__(0);\n            /******/\n          }(\n          /************************************************************************/\n\n          /******/\n          [\n          /* 0 */\n\n          /***/\n          function (module, exports, __webpack_require__) {\n            'use strict';\n\n            var _HtmlParser = __webpack_require__(1);\n\n            var _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n\n            function _interopRequireDefault(obj) {\n              return obj && obj.__esModule ? obj : {\n                'default': obj\n              };\n            }\n\n            module.exports = _HtmlParser2['default'];\n            /***/\n          },\n          /* 1 */\n\n          /***/\n          function (module, exports, __webpack_require__) {\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _supports = __webpack_require__(2);\n\n            var supports = _interopRequireWildcard(_supports);\n\n            var _streamReaders = __webpack_require__(3);\n\n            var streamReaders = _interopRequireWildcard(_streamReaders);\n\n            var _fixedReadTokenFactory = __webpack_require__(6);\n\n            var _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);\n\n            var _utils = __webpack_require__(5);\n\n            function _interopRequireDefault(obj) {\n              return obj && obj.__esModule ? obj : {\n                'default': obj\n              };\n            }\n\n            function _interopRequireWildcard(obj) {\n              if (obj && obj.__esModule) {\n                return obj;\n              } else {\n                var newObj = {};\n\n                if (obj != null) {\n                  for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n                  }\n                }\n\n                newObj['default'] = obj;\n                return newObj;\n              }\n            }\n\n            function _classCallCheck(instance, Constructor) {\n              if (!(instance instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n              }\n            }\n            /**\n             * Detection regular expressions.\n             *\n             * Order of detection matters: detection of one can only\n             * succeed if detection of previous didn't\n            \t\t * @type {Object}\n             */\n\n\n            var detect = {\n              comment: /^<!--/,\n              endTag: /^<\\//,\n              atomicTag: /^<\\s*(script|style|noscript|iframe|textarea)[\\s\\/>]/i,\n              startTag: /^</,\n              chars: /^[^<]/\n            };\n            /**\n             * HtmlParser provides the capability to parse HTML and return tokens\n             * representing the tags and content.\n             */\n\n            var HtmlParser = function () {\n              /**\n               * Constructor.\n               *\n               * @param {string} stream The initial parse stream contents.\n               * @param {Object} options The options\n               * @param {boolean} options.autoFix Set to true to automatically fix errors\n               */\n              function HtmlParser() {\n                var _this = this;\n\n                var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                _classCallCheck(this, HtmlParser);\n\n                this.stream = stream;\n                var fix = false;\n                var fixedTokenOptions = {};\n\n                for (var key in supports) {\n                  if (supports.hasOwnProperty(key)) {\n                    if (options.autoFix) {\n                      fixedTokenOptions[key + 'Fix'] = true; // !supports[key];\n                    }\n\n                    fix = fix || fixedTokenOptions[key + 'Fix'];\n                  }\n                }\n\n                if (fix) {\n                  this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n                    return _this._readTokenImpl();\n                  });\n                  this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n                    return _this._peekTokenImpl();\n                  });\n                } else {\n                  this._readToken = this._readTokenImpl;\n                  this._peekToken = this._peekTokenImpl;\n                }\n              }\n              /**\n               * Appends the given string to the parse stream.\n               *\n               * @param {string} str The string to append\n               */\n\n\n              HtmlParser.prototype.append = function append(str) {\n                this.stream += str;\n              };\n              /**\n               * Prepends the given string to the parse stream.\n               *\n               * @param {string} str The string to prepend\n               */\n\n\n              HtmlParser.prototype.prepend = function prepend(str) {\n                this.stream = str + this.stream;\n              };\n              /**\n               * The implementation of the token reading.\n               *\n               * @private\n               * @returns {?Token}\n               */\n\n\n              HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {\n                var token = this._peekTokenImpl();\n\n                if (token) {\n                  this.stream = this.stream.slice(token.length);\n                  return token;\n                }\n              };\n              /**\n               * The implementation of token peeking.\n               *\n               * @returns {?Token}\n               */\n\n\n              HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {\n                for (var type in detect) {\n                  if (detect.hasOwnProperty(type)) {\n                    if (detect[type].test(this.stream)) {\n                      var token = streamReaders[type](this.stream);\n\n                      if (token) {\n                        if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {\n                          return null;\n                        } else {\n                          token.text = this.stream.substr(0, token.length);\n                          return token;\n                        }\n                      }\n                    }\n                  }\n                }\n              };\n              /**\n               * The public token peeking interface.  Delegates to the basic token peeking\n               * or a version that performs fixups depending on the `autoFix` setting in\n               * options.\n               *\n               * @returns {object}\n               */\n\n\n              HtmlParser.prototype.peekToken = function peekToken() {\n                return this._peekToken();\n              };\n              /**\n               * The public token reading interface.  Delegates to the basic token reading\n               * or a version that performs fixups depending on the `autoFix` setting in\n               * options.\n               *\n               * @returns {object}\n               */\n\n\n              HtmlParser.prototype.readToken = function readToken() {\n                return this._readToken();\n              };\n              /**\n               * Read tokens and hand to the given handlers.\n               *\n               * @param {Object} handlers The handlers to use for the different tokens.\n               */\n\n\n              HtmlParser.prototype.readTokens = function readTokens(handlers) {\n                var tok = void 0;\n\n                while (tok = this.readToken()) {\n                  // continue until we get an explicit \"false\" return\n                  if (handlers[tok.type] && handlers[tok.type](tok) === false) {\n                    return;\n                  }\n                }\n              };\n              /**\n               * Clears the parse stream.\n               *\n               * @returns {string} The contents of the parse stream before clearing.\n               */\n\n\n              HtmlParser.prototype.clear = function clear() {\n                var rest = this.stream;\n                this.stream = '';\n                return rest;\n              };\n              /**\n               * Returns the rest of the parse stream.\n               *\n               * @returns {string} The contents of the parse stream.\n               */\n\n\n              HtmlParser.prototype.rest = function rest() {\n                return this.stream;\n              };\n\n              return HtmlParser;\n            }();\n\n            exports['default'] = HtmlParser;\n\n            HtmlParser.tokenToString = function (tok) {\n              return tok.toString();\n            };\n\n            HtmlParser.escapeAttributes = function (attrs) {\n              var escapedAttrs = {};\n\n              for (var name in attrs) {\n                if (attrs.hasOwnProperty(name)) {\n                  escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);\n                }\n              }\n\n              return escapedAttrs;\n            };\n\n            HtmlParser.supports = supports;\n\n            for (var key in supports) {\n              if (supports.hasOwnProperty(key)) {\n                HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;\n              }\n            }\n            /***/\n\n          },\n          /* 2 */\n\n          /***/\n          function (module, exports) {\n            'use strict';\n\n            exports.__esModule = true;\n            var tagSoup = false;\n            var selfClose = false;\n            var work = window.document.createElement('div');\n\n            try {\n              var html = '<P><I></P></I>';\n              work.innerHTML = html;\n              exports.tagSoup = tagSoup = work.innerHTML !== html;\n            } catch (e) {\n              exports.tagSoup = tagSoup = false;\n            }\n\n            try {\n              work.innerHTML = '<P><i><P></P></i></P>';\n              exports.selfClose = selfClose = work.childNodes.length === 2;\n            } catch (e) {\n              exports.selfClose = selfClose = false;\n            }\n\n            work = null;\n            exports.tagSoup = tagSoup;\n            exports.selfClose = selfClose;\n            /***/\n          },\n          /* 3 */\n\n          /***/\n          function (module, exports, __webpack_require__) {\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n              return typeof obj;\n            } : function (obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n\n            exports.comment = comment;\n            exports.chars = chars;\n            exports.startTag = startTag;\n            exports.atomicTag = atomicTag;\n            exports.endTag = endTag;\n\n            var _tokens = __webpack_require__(4);\n            /**\n             * Regular Expressions for parsing tags and attributes\n             *\n             * @type {Object}\n             */\n\n\n            var REGEXES = {\n              startTag: /^<([\\-A-Za-z0-9_]+)((?:\\s+[\\w\\-]+(?:\\s*=?\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n              endTag: /^<\\/([\\-A-Za-z0-9_]+)[^>]*>/,\n              attr: /(?:([\\-A-Za-z0-9_]+)\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))|(?:([\\-A-Za-z0-9_]+)(\\s|$)+)/g,\n              fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i\n            };\n            /**\n             * Reads a comment token\n             *\n             * @param {string} stream The input stream\n             * @returns {CommentToken}\n             */\n\n            function comment(stream) {\n              var index = stream.indexOf('-->');\n\n              if (index >= 0) {\n                return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);\n              }\n            }\n            /**\n             * Reads non-tag characters.\n             *\n             * @param {string} stream The input stream\n             * @returns {CharsToken}\n             */\n\n\n            function chars(stream) {\n              var index = stream.indexOf('<');\n              return new _tokens.CharsToken(index >= 0 ? index : stream.length);\n            }\n            /**\n             * Reads start tag token.\n             *\n             * @param {string} stream The input stream\n             * @returns {StartTagToken}\n             */\n\n\n            function startTag(stream) {\n              var endTagIndex = stream.indexOf('>');\n\n              if (endTagIndex !== -1) {\n                var match = stream.match(REGEXES.startTag);\n\n                if (match) {\n                  var _ret = function () {\n                    var attrs = {};\n                    var booleanAttrs = {};\n                    var rest = match[2];\n                    match[2].replace(REGEXES.attr, function (match, name) {\n                      if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {\n                        attrs[name] = '';\n                      } else if (arguments[5]) {\n                        attrs[arguments[5]] = '';\n                        booleanAttrs[arguments[5]] = true;\n                      } else {\n                        attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';\n                      }\n\n                      rest = rest.replace(match, '');\n                    });\n                    return {\n                      v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''))\n                    };\n                  }();\n\n                  if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n                }\n              }\n            }\n            /**\n             * Reads atomic tag token.\n             *\n             * @param {string} stream The input stream\n             * @returns {AtomicTagToken}\n             */\n\n\n            function atomicTag(stream) {\n              var start = startTag(stream);\n\n              if (start) {\n                var rest = stream.slice(start.length); // for optimization, we check first just for the end tag\n\n                if (rest.match(new RegExp('<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'))) {\n                  // capturing the content is inefficient, so we do it inside the if\n                  var match = rest.match(new RegExp('([\\\\s\\\\S]*?)<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'));\n\n                  if (match) {\n                    return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);\n                  }\n                }\n              }\n            }\n            /**\n             * Reads an end tag token.\n             *\n             * @param {string} stream The input stream\n             * @returns {EndTagToken}\n             */\n\n\n            function endTag(stream) {\n              var match = stream.match(REGEXES.endTag);\n\n              if (match) {\n                return new _tokens.EndTagToken(match[1], match[0].length);\n              }\n            }\n            /***/\n\n          },\n          /* 4 */\n\n          /***/\n          function (module, exports, __webpack_require__) {\n            'use strict';\n\n            exports.__esModule = true;\n            exports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;\n\n            var _utils = __webpack_require__(5);\n\n            function _classCallCheck(instance, Constructor) {\n              if (!(instance instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n              }\n            }\n            /**\n             * Token is a base class for all token types parsed.  Note we don't actually\n             * use intheritance due to IE8's non-existent ES5 support.\n             */\n\n\n            var Token =\n            /**\n             * Constructor.\n             *\n             * @param {string} type The type of the Token.\n             * @param {Number} length The length of the Token text.\n             */\n            exports.Token = function Token(type, length) {\n              _classCallCheck(this, Token);\n\n              this.type = type;\n              this.length = length;\n              this.text = '';\n            };\n            /**\n             * CommentToken represents comment tags.\n             */\n\n\n            var CommentToken = exports.CommentToken = function () {\n              /**\n               * Constructor.\n               *\n               * @param {string} content The content of the comment\n               * @param {Number} length The length of the Token text.\n               */\n              function CommentToken(content, length) {\n                _classCallCheck(this, CommentToken);\n\n                this.type = 'comment';\n                this.length = length || (content ? content.length : 0);\n                this.text = '';\n                this.content = content;\n              }\n\n              CommentToken.prototype.toString = function toString() {\n                return '<!--' + this.content;\n              };\n\n              return CommentToken;\n            }();\n            /**\n             * CharsToken represents non-tag characters.\n             */\n\n\n            var CharsToken = exports.CharsToken = function () {\n              /**\n               * Constructor.\n               *\n               * @param {Number} length The length of the Token text.\n               */\n              function CharsToken(length) {\n                _classCallCheck(this, CharsToken);\n\n                this.type = 'chars';\n                this.length = length;\n                this.text = '';\n              }\n\n              CharsToken.prototype.toString = function toString() {\n                return this.text;\n              };\n\n              return CharsToken;\n            }();\n            /**\n             * TagToken is a base class for all tag-based Tokens.\n             */\n\n\n            var TagToken = exports.TagToken = function () {\n              /**\n               * Constructor.\n               *\n               * @param {string} type The type of the token.\n               * @param {string} tagName The tag name.\n               * @param {Number} length The length of the Token text.\n               * @param {Object} attrs The dictionary of attributes and values\n               * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n               *                              is a boolean attribute\n               */\n              function TagToken(type, tagName, length, attrs, booleanAttrs) {\n                _classCallCheck(this, TagToken);\n\n                this.type = type;\n                this.length = length;\n                this.text = '';\n                this.tagName = tagName;\n                this.attrs = attrs;\n                this.booleanAttrs = booleanAttrs;\n                this.unary = false;\n                this.html5Unary = false;\n              }\n              /**\n               * Formats the given token tag.\n               *\n               * @param {TagToken} tok The TagToken to format.\n               * @param {?string} [content=null] The content of the token.\n               * @returns {string} The formatted tag.\n               */\n\n\n              TagToken.formatTag = function formatTag(tok) {\n                var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                var str = '<' + tok.tagName;\n\n                for (var key in tok.attrs) {\n                  if (tok.attrs.hasOwnProperty(key)) {\n                    str += ' ' + key;\n                    var val = tok.attrs[key];\n\n                    if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {\n                      str += '=\"' + (0, _utils.escapeQuotes)(val) + '\"';\n                    }\n                  }\n                }\n\n                if (tok.rest) {\n                  str += ' ' + tok.rest;\n                }\n\n                if (tok.unary && !tok.html5Unary) {\n                  str += '/>';\n                } else {\n                  str += '>';\n                }\n\n                if (content !== undefined && content !== null) {\n                  str += content + '</' + tok.tagName + '>';\n                }\n\n                return str;\n              };\n\n              return TagToken;\n            }();\n            /**\n             * StartTagToken represents a start token.\n             */\n\n\n            var StartTagToken = exports.StartTagToken = function () {\n              /**\n               * Constructor.\n               *\n               * @param {string} tagName The tag name.\n               * @param {Number} length The length of the Token text\n               * @param {Object} attrs The dictionary of attributes and values\n               * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n               *                              is a boolean attribute\n               * @param {boolean} unary True if the tag is a unary tag\n               * @param {string} rest The rest of the content.\n               */\n              function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {\n                _classCallCheck(this, StartTagToken);\n\n                this.type = 'startTag';\n                this.length = length;\n                this.text = '';\n                this.tagName = tagName;\n                this.attrs = attrs;\n                this.booleanAttrs = booleanAttrs;\n                this.html5Unary = false;\n                this.unary = unary;\n                this.rest = rest;\n              }\n\n              StartTagToken.prototype.toString = function toString() {\n                return TagToken.formatTag(this);\n              };\n\n              return StartTagToken;\n            }();\n            /**\n             * AtomicTagToken represents an atomic tag.\n             */\n\n\n            var AtomicTagToken = exports.AtomicTagToken = function () {\n              /**\n               * Constructor.\n               *\n               * @param {string} tagName The name of the tag.\n               * @param {Number} length The length of the tag text.\n               * @param {Object} attrs The attributes.\n               * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n               *                              is a boolean attribute\n               * @param {string} content The content of the tag.\n               */\n              function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {\n                _classCallCheck(this, AtomicTagToken);\n\n                this.type = 'atomicTag';\n                this.length = length;\n                this.text = '';\n                this.tagName = tagName;\n                this.attrs = attrs;\n                this.booleanAttrs = booleanAttrs;\n                this.unary = false;\n                this.html5Unary = false;\n                this.content = content;\n              }\n\n              AtomicTagToken.prototype.toString = function toString() {\n                return TagToken.formatTag(this, this.content);\n              };\n\n              return AtomicTagToken;\n            }();\n            /**\n             * EndTagToken represents an end tag.\n             */\n\n\n            var EndTagToken = exports.EndTagToken = function () {\n              /**\n               * Constructor.\n               *\n               * @param {string} tagName The name of the tag.\n               * @param {Number} length The length of the tag text.\n               */\n              function EndTagToken(tagName, length) {\n                _classCallCheck(this, EndTagToken);\n\n                this.type = 'endTag';\n                this.length = length;\n                this.text = '';\n                this.tagName = tagName;\n              }\n\n              EndTagToken.prototype.toString = function toString() {\n                return '</' + this.tagName + '>';\n              };\n\n              return EndTagToken;\n            }();\n            /***/\n\n          },\n          /* 5 */\n\n          /***/\n          function (module, exports) {\n            'use strict';\n\n            exports.__esModule = true;\n            exports.escapeQuotes = escapeQuotes;\n            /**\n             * Escape quotes in the given value.\n             *\n             * @param {string} value The value to escape.\n             * @param {string} [defaultValue=''] The default value to return if value is falsy.\n             * @returns {string}\n             */\n\n            function escapeQuotes(value) {\n              var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ''; // There's no lookback in JS, so /(^|[^\\\\])\"/ only matches the first of two `\"`s.\n              // Instead, just match anything before a double-quote and escape if it's not already escaped.\n\n              return !value ? defaultValue : value.replace(/([^\"]*)\"/g, function (_, prefix) {\n                return /\\\\/.test(prefix) ? prefix + '\"' : prefix + '\\\\\"';\n              });\n            }\n            /***/\n\n          },\n          /* 6 */\n\n          /***/\n          function (module, exports) {\n            'use strict';\n\n            exports.__esModule = true;\n            exports['default'] = fixedReadTokenFactory;\n            /**\n             * Empty Elements - HTML 4.01\n             *\n             * @type {RegExp}\n             */\n\n            var EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;\n            /**\n             * Elements that you can intentionally leave open (and which close themselves)\n             *\n             * @type {RegExp}\n             */\n\n            var CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;\n            /**\n             * Corrects a token.\n             *\n             * @param {Token} tok The token to correct\n             * @returns {Token} The corrected token\n             */\n\n            function correct(tok) {\n              if (tok && tok.type === 'startTag') {\n                tok.unary = EMPTY.test(tok.tagName) || tok.unary;\n                tok.html5Unary = !/\\/>$/.test(tok.text);\n              }\n\n              return tok;\n            }\n            /**\n             * Peeks at the next token in the parser.\n             *\n             * @param {HtmlParser} parser The parser\n             * @param {Function} readTokenImpl The underlying readToken implementation\n             * @returns {Token} The next token\n             */\n\n\n            function peekToken(parser, readTokenImpl) {\n              var tmp = parser.stream;\n              var tok = correct(readTokenImpl());\n              parser.stream = tmp;\n              return tok;\n            }\n            /**\n             * Closes the last token.\n             *\n             * @param {HtmlParser} parser The parser\n             * @param {Array<Token>} stack The stack\n             */\n\n\n            function closeLast(parser, stack) {\n              var tok = stack.pop(); // prepend close tag to stream.\n\n              parser.prepend('</' + tok.tagName + '>');\n            }\n            /**\n             * Create a new token stack.\n             *\n             * @returns {Array<Token>}\n             */\n\n\n            function newStack() {\n              var stack = [];\n\n              stack.last = function () {\n                return this[this.length - 1];\n              };\n\n              stack.lastTagNameEq = function (tagName) {\n                var last = this.last();\n                return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();\n              };\n\n              stack.containsTagName = function (tagName) {\n                for (var i = 0, tok; tok = this[i]; i++) {\n                  if (tok.tagName === tagName) {\n                    return true;\n                  }\n                }\n\n                return false;\n              };\n\n              return stack;\n            }\n            /**\n             * Return a readToken implementation that fixes input.\n             *\n             * @param {HtmlParser} parser The parser\n             * @param {Object} options Options for fixing\n             * @param {boolean} options.tagSoupFix True to fix tag soup scenarios\n             * @param {boolean} options.selfCloseFix True to fix self-closing tags\n             * @param {Function} readTokenImpl The underlying readToken implementation\n             * @returns {Function}\n             */\n\n\n            function fixedReadTokenFactory(parser, options, readTokenImpl) {\n              var stack = newStack();\n              var handlers = {\n                startTag: function startTag(tok) {\n                  var tagName = tok.tagName;\n\n                  if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {\n                    parser.prepend('<TBODY>');\n                    prepareNextToken();\n                  } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {\n                    if (stack.lastTagNameEq(tagName)) {\n                      closeLast(parser, stack);\n                    } else {\n                      parser.prepend('</' + tok.tagName + '>');\n                      prepareNextToken();\n                    }\n                  } else if (!tok.unary) {\n                    stack.push(tok);\n                  }\n                },\n                endTag: function endTag(tok) {\n                  var last = stack.last();\n\n                  if (last) {\n                    if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {\n                      // cleanup tag soup\n                      closeLast(parser, stack);\n                    } else {\n                      stack.pop();\n                    }\n                  } else if (options.tagSoupFix) {\n                    // cleanup tag soup part 2: skip this token\n                    readTokenImpl();\n                    prepareNextToken();\n                  }\n                }\n              };\n\n              function prepareNextToken() {\n                var tok = peekToken(parser, readTokenImpl);\n\n                if (tok && handlers[tok.type]) {\n                  handlers[tok.type](tok);\n                }\n              }\n\n              return function fixedReadToken() {\n                prepareNextToken();\n                return correct(readTokenImpl());\n              };\n            }\n            /***/\n\n          }\n          /******/\n          ])\n        );\n      });\n\n      ;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      exports.existy = existy;\n      exports.isFunction = isFunction;\n      exports.each = each;\n      exports.eachKey = eachKey;\n      exports.defaults = defaults;\n      exports.toArray = toArray;\n      exports.last = last;\n      exports.isTag = isTag;\n      exports.isScript = isScript;\n      exports.isStyle = isStyle;\n      /**\n       * Determine if the thing is not undefined and not null.\n       *\n       * @param {*} thing The thing to test\n       * @returns {boolean} True if the thing is not undefined and not null.\n       */\n\n      function existy(thing) {\n        return thing !== void 0 && thing !== null;\n      }\n      /**\n       * Is this a function?\n       *\n       * @param {*} x The variable to test\n       * @returns {boolean} True if the variable is a function\n       */\n\n\n      function isFunction(x) {\n        return 'function' === typeof x;\n      }\n      /**\n       * Loop over each item in an array-like value.\n       *\n       * @param {Array<*>} arr The array to loop over\n       * @param {Function} fn The function to call\n       * @param {?Object} target The object to bind to the function\n       */\n\n\n      function each(arr, fn, target) {\n        var i = void 0;\n        var len = arr && arr.length || 0;\n\n        for (i = 0; i < len; i++) {\n          fn.call(target, arr[i], i);\n        }\n      }\n      /**\n       * Loop over each key/value pair in a hash.\n       *\n       * @param {Object} obj The object\n       * @param {Function} fn The function to call\n       * @param {?Object} target The object to bind to the function\n       */\n\n\n      function eachKey(obj, fn, target) {\n        for (var key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            fn.call(target, key, obj[key]);\n          }\n        }\n      }\n      /**\n       * Set default options where some option was not specified.\n       *\n       * @param {Object} options The destination\n       * @param {Object} _defaults The defaults\n       * @returns {Object}\n       */\n\n\n      function defaults(options, _defaults) {\n        options = options || {};\n        eachKey(_defaults, function (key, val) {\n          if (!existy(options[key])) {\n            options[key] = val;\n          }\n        });\n        return options;\n      }\n      /**\n       * Convert value (e.g., a NodeList) to an array.\n       *\n       * @param {*} obj The object\n       * @returns {Array<*>}\n       */\n\n\n      function toArray(obj) {\n        try {\n          return Array.prototype.slice.call(obj);\n        } catch (e) {\n          var _ret = function () {\n            var ret = [];\n            each(obj, function (val) {\n              ret.push(val);\n            });\n            return {\n              v: ret\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n      }\n      /**\n       * Get the last item in an array\n       *\n       * @param {Array<*>} array The array\n       * @returns {*} The last item in the array\n       */\n\n\n      function last(array) {\n        return array[array.length - 1];\n      }\n      /**\n       * Test if token is a script tag.\n       *\n       * @param {Object} tok The token\n       * @param {String} tag The tag name\n       * @returns {boolean} True if the token is a script tag\n       */\n\n\n      function isTag(tok, tag) {\n        return !tok || !(tok.type === 'startTag' || tok.type === 'atomicTag') || !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);\n      }\n      /**\n       * Test if token is a script tag.\n       *\n       * @param {Object} tok The token\n       * @returns {boolean} True if the token is a script tag\n       */\n\n\n      function isScript(tok) {\n        return isTag(tok, 'script');\n      }\n      /**\n       * Test if token is a style tag.\n       *\n       * @param {Object} tok The token\n       * @returns {boolean} True if the token is a style tag\n       */\n\n\n      function isStyle(tok) {\n        return isTag(tok, 'style');\n      }\n      /***/\n\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:/webpack/bootstrap c9988e4825e1b6d62704","webpack:///src/main.js","webpack:///src/postscribe.js","webpack:///src/write-stream.js","webpack:///~/prescribe/dist/prescribe.js","webpack:///src/utils.js"],"names":["doNothing","afterDequeue","beforeWrite","options","args","stream","active","name","postscribe","doc","ownerDocument","open","write","writeln","afterWrite","str","oldOnError","onerror","nextStream","utils","queue","nextId","el","window","cancel","beforeEnqueue","streams","WriteStream","proxyHistory","scriptStack","setData","arg","_callFunction","tok","tokens","_writeStaticTokens","_handleScriptToken","_handleStyleToken","proxyRoot","DEBUG_CHUNK","chunk","root","_buildChunk","proxy","test","id","actual","push","tokenRaw","raw","_walkChunk","isProxy","isElement","stack","beforeWriteToken","_writeStyleToken","remainder","appendChild","_insertCursor","deferredRemote","_writeScriptToken","done","afterAsync","content","text","_scriptLoadHandler","cleanup","error","reattachEventListener","handler","onload","failure","msg","success","err","onreadystatechange","readyState","_shouldRelease","existy","isFunction","eachKey","toArray","isTag","isScript","isStyle"],"mappings":"AAAA;;;;;;;;;AASA,CAAC,SAAA,gCAAA,CAAA,IAAA,EAAA,OAAA,EAAA;AACD,MAAA,O,OAAA,K,QAAA,I,0BAAA,ECVA,MAAA,CAAA,OAAA,GAAA,OAAA,EAAA,CDUA,KCTA,IAAA,OAAA,MAAA,KAAA,UAAA,IAAA,MAAA,CAAA,GAAA,E,oBAAA,KAEA,IAAA,OAAA,OAAA,KAAA,QAAA,EACA,OAAA,CAAA,YAAA,CAAA,GAAA,OAAA,EAAA,CADA,KAGA,IAAA,CAAA,YAAA,CAAA,GAAA,OAAA,EAAA;AACA,CDEA,ECFA,IDEA,ECFA,YAAA;AACA;AAAA;AAAA,cAAA,OAAA,EAAA;AAAA;;;;;AAEA;AAAA,UAAA,gBAAA,GAAA,EAAA;AACA;;AACA;AAAA;;AACA;;AAAA,eAAA,mBAAA,CAAA,QAAA,EAAA;AACA;;AACA;AAAA;;;;AAEA;AAAA,iBAAA,gBAAA,CAAA,QAAA,CAAA,CAAA,OAAA;AACA;;;;;AAEA;;AAAA,YAAA,MAAA,GAAA,gBAAA,CAAA,QAAA,CAAA,GAAA;AACA;AAAA,UAAA,OAAA,EAAA,EADA;;;sBAAA;;AAGA;AAAA,UAAA,MAAA,EAAA;AACA;;AAJA,SAAA;AAKA;;;;;;;;AAGA;;AACA;AAAA;;;;;AAEA;;AACA;AAAA;;;;;AAEA;AAAA;AACA;;;;AAEA;AAAA;;AACA;;;AAAA,MAAA,mBAAA,CAAA,CAAA,GAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;ACtCA;;AAAA,aAAA,mBAAA,CAAA,CAAA,CAAA;;KDQA;;;;;;;;;;;;;;;;;;;;;;;;AE6IwBQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/IxB,UAAA,KAASR,GAAT,uBACC,CAAA,MAAA,CADD;;AAGA,eAAA,uBAAA,CAAA,GAAA,EAAA;AAAA,YAAA,GAAA,IAAA,GAAA,CAAA,UAAA,EAAA;AAAA,iBAAA,GAAA;AAAA,SAAA,MAAA;AAAA,cAAA,MAAA,GAAA,EAAA;;AAAA,cAAA,GAAA,IAAA,IAAA,EAAA;AAAA,iBAAA,IAAA,GAAA,IAAA,GAAA,EAAA;AAAA,kBAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,GAAA,EAAA,GAAA,CAAA,EAAA,MAAA,CAAA,GAAA,CAAA,GAAA,GAAA,CAAA,GAAA,CAAA;AAAA;AAAA;;AAAA,UAAA,MAAA,CAAA,SAAA,CAAA,GAAA,GAAA;AAAA,iBAAA,MAAA;AAAA;AAAA;;;;;;;;;;;;;AAKgB;;;;;;;AASdC,UAAAA,OAAAA,GATc;;;;6BAAA;;;;;+BAAA;;;;;mCAAA;;;;;6BAAA;;;;;qBAAA;;;;;AAAA,QAAA,aAAA,EAAA,SAAA;;AAsCd;;;;;AAKAC,QAAAA,gBAAa,EAAA,SAAA,gBAAA,CAAA,GAAA,EAAA;AAAA,iBAAA,GAAA;AA3CC,SAAA;;AA6Cd;;;;;AAKA,QAAA,WAAA,EAAA,SAAA,WAAA,CAAA,GAAA,EAAA;;SAlDc;;;;;AAAA,QAAA,IAAA,EAAA,SAAA;;;;;;;AAAhB,QAAA,KAAA,EAAA,SAAA,KAAA,CAAA,CAAA,EAAA;;AA+DA,SA/DgB;;;;;AAqEd,QAAA,YAAU,EAAA;AArEI,OASdD;AA+DEE,UAAAA,MAAAA,GAAAA,CAAAA;AACAC,UAAAA,KAAKC,GAALD,EAAAA;AACAD,UAAAA,MAAAA,GAAAA,IAAAA;;AAEH,eAAA,UAAA,GAAA;;;AAED,YAAA,IAAA,EAAA;AACEG,cAAAA,OAAS,GAAA,KAAA,CAAA,IAAA,CAATA,IAAS,CAATA;AAEA,UAAA,OAAA,CAAA,YAAA;AACAA,UAAAA,IAAAA,CAAAA,MAAAA,GAAAA,SAAAA,CAAAA,KAAAA,CAAAA,SAAAA,EAAAA,IAAAA,CAAAA;AACAA,UAAAA,OAAOC,CAAPD,gBAAAA;AACAE;;;AAGA,eAAMC,SAAN,CAAeC,EAAf,EAAA,IAAA,EAAA,OAAA,EAAA;2DAAA,CAEc;;AAEZC,QAAAA,MAAAA,CAAAA,EAAAA,GAFY,MAAA,EAEZA;AACAC,QAAAA,MAAAA,CAAAA,IAAAA,GAHY,OAAA,CAAA,IAAA,IAAA,MAAA,CAAA,EAGZA;AACAC,QAAAA,UAAAA,CAASJ,OAATI,CAAaA,MAAAA,CAAAA,IAAbA,IAAaA,MAAbA,CANF,C;;AASA,YAAA,GAAA,GAASD,EAAAA,CAAT,aAAA;AAEEN,YAAAA,KAAOM,GAAPN;AACAH,UAAAA,KAAAA,EAAAA,GAAQW,CAARX,KADAG;AAED,UAAA,IAAA,EAAA,GAAA,CAAA,IAFCA;0BAAAA;AAIF,UAAA,OAAcG,EAAd,GAAmB,CAAA;AAJjBH,SAAAA;;AAOAM,iBAAO,MAAPA,CAAO,GAAPA,EAAO;AAAA,UAAA,GAAA,GAAA,OAAA,CAAA,WAAA,CAAA,GAAA,CAAA;AAAIG,UAAAA,MAAAA,CAAJ,KAAIA,CAAJ,GAAIA;AAAJ,UAAA,OAAA,CAAA,UAAA,CAAA,GAAA;;;AAHU,QAAA,QAAA,CAAA,GAAA,EAAA;AAIjBF,UAAAA,KAAAA,EAAAA,SAJiB;AAIR,UAAA,IAAA,EAAA,SAJQ;AAIJE,UAAAA,KAAAA,EAAJ,SAAA,KAAA,GAAA;AAAA,iBAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAA,GAAA,GAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;;AAAA;;AAJX,mBAAA,MAAA,CAAA,GAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA;WAAmB;AAOnB,UAAA,OAAA,EAAA,SAAA,OAAA,GAAA;AACMC,iBAAAA,IAAAA,KAAaV,GAAAA,SAAWW,CAAXX,MAAbU,EAAmChB,GAAAA,GAAzC,KAAA,CAAA,KAAA,CAAMgB,EAAN,KAAA,GAAA,CAAMA,EAAN,KAAA,GAAA,KAAMA,EAAN,KAAA,EAAMA,EAAN;;AAEA;;AAEAV,mBAAWW,MAAAA,CAAXX,GAAqB,CAAA,IAArBA,CAAqB,EAArBA,IAAqB,IAAVW,CAAXX;AACEH;AAbiB,SAAA,CAAA,CAfnB,C;;;AAgCA,YAAA,UAAA,GAAA,MAAA,CAAA,GAAA,CAAA,OAAA,IAAA,SAAA,CAhCA,CAkCE;AACA;;;AAEA,UAAA,OAAA,CAAA,KAAA,CAAA;AAAA,YAAA,GAAA,EAAA,GAAA,GAAA,KAAA,GAAA,GAAA,GAAA,IAAA,GAAA;AAAA,WAAA;AACAG,UAAAA,UAAAA,CAAWW,KAAXX,CAAAA,MAAqBU,CAAAA,GAArBV,EAAqBU,CAArBV,GAAqBU,EAArBV,GAAqBU,EAArBV,IAAqBU,CAArBV;UAtCF,CAyCEA;;;AACAY,QAAAA,MAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAAA,YAAAA;AATFZ;+BASEY,CAIH;;;;AAGC,UAAA,OAAIC,CAAJ,IAAA;AACEhB,UAAAA,MAAAA,GAAAA,IAAAA;AADF,UAAA,UAEO;AACLiB,SAVAF;AAYAG,eAAAA,MAAAA;AACA;;;AAGFlB,YAAAA,KAAAA,CAAUgB,UAAVhB,CAAUgB,OAAVhB,CAAAA,EAAAA;;;;AAEA,SAFAA,MAEA,IAAA,OAAA,KAAA,OAAA,EAAA;AACA,UAAA,KAAI,GAAJ,EAAA;AACEmB,UAAAA,MAAKC,GAALD,IAAAA;AADF,UAAA,MAEO,GAAA,CAFP;AAGEA;AACD;;AAED,QAAA,OAAMlB,GAAAA,KAAO,CAAA,QAAPA,CAAN,OAAMA,EAAN,OAAMA,CAAN,C,CAEAkB;;AACEE,YAAAA,KAAAA,IAAAA,CAAQ,EAARA,CAAAA,EAAQ;AACN,UAAA,EAAA,GAAA,MAASnB,CAAT,QAAA,CAAiB,cAAjB,CAAiB,EAAA,CAAA,MAAA,CAAA,CAAA,CAAjB,CAAA;AACED,SAFJoB,MAEIpB;AACD,UAAA,EAFD,GAAA,EAAA,CAAA,MAAA,GAEO,EAAA,CAAA,CAAA,CAFP,GAEO,EAAN;AACCA;;AAEH,YAAA,IAAA,GAAA,CAAA,EAAA,EAAA,IAAA,EAAA,OAAA,CAAA;;AAGHD,UAAAA,MAAQsB,EAAAA,SAARtB,MAAQsB,GAARtB;AACAiB,gBAAAA,IAAWhB,CAAXgB,MAAAA,EAAAA;;AAEKd,aAFLc,MAEA;AACEF,cAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,SAAAA;AACD;;;;AAKH,QAAA,KAAA,CAAA,IAAA,CAAA,IAAA;;AAEEQ,YAAAA,CAFwB,MAExBA,EAFwB;AAGxB,UAAA,UAAA;AAHwB;;AAMxBC,eAAAA,EAAAA,CAAAA,UAAAA;AANF;;;;;;;;;;;;;AC9LA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,UAAA,YAAA,GAAA,WAAA;;;;;;;;;AASA,eAAA,OAAA,CAAA,EAAA,EAAA,IAAA,EAAA;;wCAAA,C;;;AAOA;;;;;;;;;;AAOG,eAAA,OAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AACF,YAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,IAAA;AAED,YAAA,IAAA,GAAA,QAAA,GAAA,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BkC;;;;;;AAK9B,iBAAA,WAAA,CAAc,IAAd,EAAA;;;AAGA,UAAA,eAAe,CAAf,IAAe,EAAf,WAAe,CAAf;;AAEA,eAAA,IAAA,GAAA,IAAA;AACA,eAAA,OAAA,GAAA,OAAA;AACA,eAAKC,GAAL,GAAKA,IAAAA,CAAL,aAAA;;AAEA,eAAA,MAAA,GAAA,IAAA,WAAA,CAAA,SAAA,CAAA,CAAA,EAAA,EAAA;AAAA,YAAA,OAAA,EAAA,OAAA,CAAA;AAAA,WAAA,CAAA,CATA,C;;AAYA,eAAKC,OAAL,GAAKA,CAAL,IAAKA,CAAL,CAZA,C;AAeAC;;AACD,eAAA,YAAA,GAAA,EAAA,CAhBC,CAkBF;;;;;;AAKAlB;;;;;;;;AAOI,QAAA,WAAMmB,CAAAA,SAAN,CAAY,KAAZ,GAAA,SAAA,KAAA,GAAA;;;AAGE,WAAA,WAAKC,GAAAA,KAAL,UAAA,EAAA,IAAA,CAAA,KAAA,CAAA,WAAA,EAAA,SAAA,EAHF,CAKE;AACD;AACF;;;;;;;;;;;;SAPC;AAiBF;;;;;;;;;;;;;;;;;;;;AAaA;;;;;;;;AAQA,QAAA,WAAQC,CAAAA,SAAR,CAAc,UAAd,GAAO,SACL,UADK,CACMd,IADN,EAAP;AAGEc,eAAAA,MAAAA,CAAM,MAANA,CAAAA,IAAAA;AAEA,cAAA,GAAA,GAAA,KAAS,CAAT;AACEC,cAAAA,MAAAA,GAAAA,KAAAA,CAAAA;AACD,cAAA,KAAA,GAAA,KAAA,CAAA;AACF,cAAA,MAAA,GAAA,EAAA,CARD,CAUA;;AACE,iBAAKC,CAAAA,GAAAA,GAAAA,KAAL,MAAKA,CAAL,SAAKA,EAAAA,KAAL,EAAA,MAAA,GAAA,KAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAKA,IAAL,EAAA,KAAA,GAAA,KAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,EAAA;AACD,YAAA,GAAA,GAAA,KAAA,OAAA,CAAA,gBAAA,CAAA,GAAA,CAAA;;AAED,gBAAA,GAAA,EAAA;AACE,cAAA,MAAKC,CAAAA,IAAL,CAAA,GAAA;AACD;;;AAGC,cAAA,MAAKC,CAAAA,MAAL,GAAKA,CAAL,EAAA;AACD,iBAAA,kBAAA,CAAA,MAAA;;;AAGH,cAAA,MAAA,EAAA;;;;;;;SAvBE;AA8BFF;;;;;;;;;AASE,QAAA,WAAKP,CAAL,SAAA,CAAA,kBAAA,GAAA,SAAA,kBAAA,CAAA,MAAA,EAAA;AACA,cAAA,KAAKU,GAAL,KAAA,WAAA,CAAA,MAAA,CAAA;;AAEA,cAAIC,CAAAA,KAAAA,CAAJ,MAAA,EAAiB;AACfC;AACD,mBAAA,IAAA;;;;AAID,eAAA,YAAA,IAAiB,KAAA,CAAA,KAAjB;AACEA,eAAAA,SAAAA,CAAAA,SAAAA,GAAwB,KAAKC,CAA7BD,IAAAA;;;AAGF,YAAA,KAAOA,CAAP,cAAA,GAAA,KAAA,SAAA,CAAA,SAAA;;;AAGF,eAAA,UAAA;;;;;;;SAhBE;AAuBFE;;;;;;;;;AASE,QAAA,WAAA,CAAA,SAAA,CAAA,WAAA,GAAA,SAAA,WAAA,CAAA,MAAA,EAAA;AACA,cAAMC,MAAAA,GAAN,KAAA,OAAA,CAAA,MAAA,CADA,CAGA;;AACA,cAAA,GAAK,GAAL,EAAA,CAJA,CAME;;0BANF,C;;AAUE,cAAA,KAAIV,GAAJ,EAAA;AACE,cAAA,GAAA,GAAA,MAAA,CAAA,MAAA;;AACA,eAAA,IAAM,CAAA,GAAA,CAAN,EAAM,CAAA,GAAD,GAAL,EAAqBW,CAAhB,EAAL,EAAA;AACE,gBAAA,GAAA,GAAMC,MAAKxB,CAAX,CAAWA,CAAX;;AAGAyB,YAAAA,GAAAA,CAAAA,IAAAA,CAAAA,QAAAA;;AAEA,gBAAA,GAAA,CAAA,KAAA,EAAA;AACA;AACE;AACAH,kBAAAA,CAAAA,cAAAA,IAAAA,CAAAA,GAAAA,CAAAA,OAAAA,CAAAA,EAAAA;AACE,oBAAA,EAAA,GAAA,MAAA,EAAA,CADFA,CAKD;;AACF,gBAAA,MAAA,CAAA,IAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,EAAA,MAAA,QAAA,GAAA,KAAA,GAAA,EAAA,GAAA,KAAA,CAAA,EANGA,CAQJ;;AACA,oBAAA,GAAA,CAAA,KAAA,CAAA,EAAA,KAAA,YAAA,IAAA,GAAA,CAAA,KAAA,CAAA,EAAA,KAAA,WAAA,EAAA;AACAG;8BAEA;AACAH,kBAAAA,GAAMI,CAANJ,IAAAA,KAAWV,WAAXU,GAAWV,EAAXU,GAAmCK,MAAxBf,GAAAA,CAAXU,OAAmCK,GAAnCL,GAAmCK,GAAnCL,QAAmCK,GAAnCL,UAAmCK,GAAnCL,EAAmCK,IAAnCL,GAAAA,CAAAA,KAAAA,GAAAA,KAAAA,GAAAA,GAAmCK,C;AACpC;AACF;aAlBK,M;AAoBN;AAAO;AAELC,cAAAA,MAAKA,CAAAA,IAALA,CAFK,QAELA,E,CAEAN;;AAJF,cAAA,KAAA,CAAA,IAAA,CAAA,GAAA,CAAA,IAAA,KAAA,QAAA,GAAA,QAAA,GAAA,EAAA;;;;;;;;;;AAaFO,SAnDE;AAqDA;;;;;;;AAOE,QAAA,WAAA,CAAA,SAAA,CAAA,UAAA,GAAA,SAAA,UAAA,GAAA;AACA,cAAA,IAAKC,GAAL,KAAc,CAAd;AACE,cAAA,KAAIC,GAAAA,CAAJ,KAAA,SAAIA,CAAJ,CAFF,CAII;;AACAtB,iBAAAA,KAAAA,CAAAA,MAAAA,CAAc,IAAdA,GAAAA,KAAAA,CAAAA,KAAAA,EAAAA,CAAAA,EAAAA;AACD,gBAAA,SAAA,GAAA,IAAA,CAAA,QAAA,KAAA,CAAA;gEADCA,CAIF;;AAEA,gBAAA,CAAA,OAAA,EAAA;AACE,kBAAA,SAAA,EAAA;AACA;AACD,qBAAA,OAAA,CAAA,OAAA,CAAA,IAAA,EAAA,IAAA,CAAA,IAAA,IAAA;AACF,gBAAA,OAAA,CAAA,IAAA,EAAA,IAAA,CAAA;eAJC,CAOFuB;;;AACD,kBAAA,eAAA,GAAA,IAAA,CAAA,UAAA,IAAA,OAAA,CAAA,IAAA,CAAA,UAAA,EAAA,SAAA,CAAA;;;;AAGH,qBAAA,OAAA,CAAA,eAAA,EAAA,WAAA,CAAA,IAAA;;aAjBQvB,C;;;;;AAsBRM,SA3BI;;;;;;;;;AAmCFH,cAAAA,KAAAA,GAAAA,IAAAA;;AAEAA,cAAAA,SAAW9B,GAAL,KAAamD,MAAb,CAANrB,KAAM,EAANA;;AAEE,cAAA,SAAA,EAAA;AACA;AACD,iBAAA,UAAA,CAAA,OAAA,CAAA,SAAA;;;AAGC,UAAA,GAAA,CAAA,GAAA,GAAA,GAAA,CAAA,KAAA,CAAA,GAAA,IAAA,GAAA,CAAA,KAAA,CAAA,GAAA;AAEA,UAAA,GAAA,GAAA,KAAA,OAAA,CAAA,gBAAA,CAAA,GAAA,CAAA;;AACA,cAAA,CAAA,GAAA,EAAA;AAJF;AAME;AACD;;AAED,cAAA,GAAA,CAAA,GAAA,IAAA,KAAA,WAAA,CAAA,MAAA,EAAA;AACA;AACE;AADF;;WADA,M;AAMF,iBAAA,cAAA,CAAA,GAAA;;;;;;;AAKAI,S;;;;;;;;;AAUEJ,cAAAA,SAAW9B,GAAL,KAAamD,MAAb,CAANrB,KAAM,EAANA;;AAEA,cAAA,SAAA,EAAS;AACP;AACA,iBAAKsB,UAAL,CAAA,OAAA,CAAA,SAAA;AACD;;AAED,UAAA,GAAA,CAAIC,IAAJ,GAAA,GAAA,CAAe,KAAf,CAAe,IAAf,IAAe,GAAA,CAAA,KAAA,CAAA,IAAf,IAAe,UAAf;AAEC,UAAA,GAAA,GAAA,KAAA,OAAA,CAAA,gBAAA,CAAA,GAAA,CAAA;;;AAGH;;;;;;;AAKAD,S;;;;;;;;AAOI,QAAA,WAEO,CAAA,SAFP,CAEO,gBAFP,GAEO,SAAA,gBAAA,CAAA,GAAA,EAAA;AACLjC,cAAAA,EAAAA,GAAGmC,KAAHnC,WAAGmC,CAAHnC,GAAGmC,CAAHnC;;AAEH,eAAA,aAAA,CAAA,EAAA,EAAA,WAAA,EAHQ,C;;;AAMX,cAAA,GAAA,CAAA,OAAA,EAAA;;;;;;;SARI;AAeF;;;;;;;;;AASA,cAAA,EAAA,GAAA,KAAA,GAAA,CAAA,aAAA,CAAA,GAAA,CAAA,OAAA,CAAA;;;;;;;;AAUFoC;;;;;;;;;;AAUA,eAAA,UAAA,CAAA,eAAA,KAAA,GAAA,KAAA;;;;;;;;AAOEzB;;;;;;;;;;;;;AAYA;;;;;;;;AAQA,QAAA,WAAA,CAAA,SAAA,CAAA,aAAA,GAAA,SAAA,aAAA,CAAA,GAAA,EAAA;AACA;;AAEA,iBAAA,OAAA,CAAA,KAAA,CAAA;AAAA,cAAA,GAAA,EAAA;AAAA,aAAA;;AAEA;;AAEA,eAAA,WAAA,CAAA,KAAA,GAPA,CASE;;AACA,eAAA,KAAA,CAAK0B,KAAL,CAAA,IAAA,EAAA,GAAsB,CAAtB,WAAA,EAVF,C;AAcF;;;;;;;;;SAdE;AAqBFC;;;;;;;;;AASMC,QAAAA,WAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,GAAAA,SAAAA,iBAAAA,CAAAA,GAAAA,EAAAA,IAAAA,EAAAA;AACAC,cAAAA,EAAAA,GAAAA,KAAAA,YAAAA,CAAAA,GAAAA,CAAAA;;AAF0B,cAAA,YAA5B,GAAA,KAAA,cAAA,CAAA,EAAA,CAA4B;;AAI7B,cAAA,UAAA,GAAA,KAAA,OAAA,CAAA,UAAA;;AAED,cAAI,GAAA,CAAA,GAAJ,EAAI;AACF;AACA,YAAA,EAAA,CAAA,GAAA,GAAI,GAAA,CAAJ,GAAA;;AACED,iBAAAA,kBAAAA,CAAAA,EAAAA,EAAAA,CAAAA,YAAAA,GAAAA,YAAAA;AACD,cAAA,IAAA;AACD,cAAA,UAAU;AACV,aAHEA,GAGF,UAHEA;AAIFA;;;;;AAIJ,gBAAA,CAAA,EAAA,CAAA,GAAA,IAAA,YAAA,EAAA;;;;;;;SAhBMA;AAuBJ;;;;;;;;AAQA,QAAA,WAAQE,CAAR,SAAA,CAAiB,YAAjB,GAAiB,SAAA,YAAA,CAAA,GAAA,EAAA;AACfzC,cAAAA,EAAG0C,GAAH1C,KAAUW,GAAVX,CAAAA,aAAAA,CAAAA,GAAAA,CAAAA,OAAAA,CAAAA,CADe,C;;AAIjB,UAAA,KAAA,CAAA,OAAA,CAAA,GAAA,CAAA,KAAA,EAAA,UAAA,IAAA,EAAA,KAAA,EAAA;;WAAA,EAJiB,C;;;;;;;SAAjB;AAcF2C;;;;;;;;;AASI,QAAA,WAAIJ,CAAJ,SAAA,CAAkB,kBAAlB,GAAkB,SAAA,kBAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AAChBA,mBAAAA,OAAAA,GAAAA;AACD,YAAA,EAAA,GAAA,EAAA,CAAA,MAAA,GAAA,EAAA,CAAA,kBAAA,GAAA,EAAA,CAAA,OAAA,GAAA,IAAA;AACDA;;;;AAIAK,mBAAAA,OAAAA,GAAAA;AACAC,YAAAA,OAAAA;;AACA,gBAAIN,IAAAA,IAAJ,IAAA,EAAkB;AAChBA,cAAAA,IAAAA;AACD;;AACDA,YAAAA,IAAAA,GAAAA,IAAAA;AACD;;AAED,mBAASO,OAAT,CAASA,GAAT,EAAA;AACE,YAAA,OAAA;AACA,YAAA,KAAIC,CAAJ,GAAIA,CAAJ;;AACE/C,gBAAAA,IAAAA,IAAAA,IAAAA,EAAAA;AACD,cAAA,IAAA;AACF;;;AAED8C;;;AAGA,gBAAA,OAAkB,GAAA,EAAA,CAAA,OAAA,GAAA,CAAlB;;AACEE,gBADgB,OAAA,IAAA,IAChBA,EADgB;AAEd,cAAA,EAAA,CAAA,QAAA,GAAA,CAAA,GAAgB,OAAhB;AACE;AACEhD;;AAEAiD,UAAAA,qBAASC,CAAAA,EAAAA,EAATD,MAASC,CAATD;AACD,UAAA,qBAAA,CAAA,EAAA,EAAA,OAAA,CAAA;;AAEHE,UAAAA,QAAAA,CAAAA,EAAAA,EAAAA;AATc,YAAA,MAAA,EAAA,SAAA,MAAA,GAAA;AAYhBxD,kBAZgB,EAAA,CAAA,OAYhBA,EAZgB;AAad,oBAAA;AACE,kBAAA,EAAI,CAAA,OAAJ,CAAI,KAAJ,CAAI,IAAJ,EAAI,KAAA,CAAA,SAAA,CAAA,KAAA,CAAA,IAAA,CAAA,SAAA,EAAA,CAAA,CAAJ;AACEK,iBAFJ,CAEIA,OAAAA,GAAAA,EAAAA;AACA,kBAAA,OAAOoD,CAAAA;AAAP,oBAAA,GAAY,EAAA,2BAAA,GAAA,GAAA,KAAA,GAAA,EAAA,CAAA;AAALA,mBAAAA,CAAP;AACAH;AACA;;AACD,cAAA,OAAA;AACF,aAXDE;AAYAF,YAAAA,OAAAA,EAAAA,SAASC,OAATD,GAAAA;AArBc,kBAAA,EAAA,CAAA,QAAA,EAAA;AAwBhBI,oBAxBgB;AAyBV,kBAAA,EAAA,CAAA,QAAA,CAAA,KAAA,CAAA,IAAA,EAAA,KAA2BrD,CAAGsD,SAA9B,CAAJ,KAAI,CAA2C,IAA3C,CAA2C,SAA3C,EAA2C,CAA3C,CAAA;AACFH,iBAFJE,CAEIF,OAAAA,GAAAA,EAAAA;AACD,kBAAA,OAAA,CAAA;AAAA,oBAAA,GAAA,EAAA,4BAAA,GAAA,GAAA,KAAA,GAAA,EAAA,CAAA;AAAA,mBAAA,CAAA;AACF;AA5BH;;;;;;AAgCF,aAvBMA;;;;;;AAAAA,WAAAA,CAAAA;SAlCF;AAgEJI;;;;;;;;;;;;;;AClmBF,eAAA,WAAA;AACA,O;;AAEA,MAAA,OAAA,CAAA,SAAA,CAAA,GAAA,WAAA;AAEA;AAAA,K;AACA;;AACA;AAAA,cAAA,MAAA,EAAA,OAAA,EAAA,mBAAA,EAAA;AAEA;;;;;;;;;AASA,OAAC,SAAA,gCAAA,CAAA,IAAA,EAAA,OAAA,EAAA;AACD,YAAA,IAAA,EACA,MAAA,CAAA,OAAA,GAAA,OAAA,EAAA,CADA,KAEA,IAAA,OAAA,MAAA,KAAA,UAAA,IAAA,MAAA,CAAA,GAAA,E,oBAAA,KAEA,IAAA,OAAA,OAAA,KAAA,QAAA,EACA,OAAA,CAAA,WAAA,CAAA,GAAA,OAAA,EAAA,CADA,KAGA,IAAA,CAAA,WAAA,CAAA,GAAA,OAAA,EAAA;AACA,OATA,EASA,IATA,EASA,YAAA;AACA;AAAA;AAAA,oBAAA,OAAA,EAAA;AAAA;;;;;AAEA;AAAA,gBAAA,gBAAA,GAAA,EAAA;AAEA;AAAA;;AACA;;AAAA,qBAAA,mBAAA,CAAA,QAAA,EAAA;AAEA;AAAA;;;;AAEA;AAAA,uBAAA,gBAAA,CAAA,QAAA,CAAA,CAAA,OAAA;;;;AAGA;;AAAA,kBAAA,MAAA,GAAA,gBAAA,CAAA,QAAA,CAAA,GAAA;AACA;AAAA,gBAAA,OAAA,EAAA,EADA;;;4BAAA;;AAGA;AAAA,gBAAA,MAAA,EAAA;AACA;;AAJA,eAAA;;;;;;;AASA;AAAA;;;;;AAGA;AAAA;;;;;AAEA;AAAA;AAGA;AAAA;;AACA;;;AAAA,YAAA,mBAAA,CAAA,CAAA,GAAA,OAAA;AAEA;AAAA;;AACA;;AAAA,YAAA,mBAAA,CAAA,CAAA,GAAA,gBAAA;AAEA;AAAA;;;;;;;;AAIA;;AAAA,mBAAA,mBAAA,CAAA,CAAA,CAAA;;WAvCA;AAyCA;;;;AAEA;;;;;;AAKA,gBAAA,WAAA,GAAA,mBAAA,CAAA,CAAA,CAAA;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;AAmBA,gBAAA,MAAA,GAAA,mBAAA,CAAA,CAAA,CAAA;;AAEA,qBAAA,sBAAA,CAAA,GAAA,EAAA;AAAA,qBAAA,GAAA,IAAA,GAAA,CAAA,UAAA,GAAA,GAAA,GAAA;AAAA,2BAAA;AAAA,eAAA;AAAA;;;;;;;;;;;;;;;;;;;AAIA,qBAAA,eAAA,CAAA,QAAA,EAAA,WAAA,EAAA;AAAA,kBAAA,EAAA,QAAA,YAAA,WAAA,CAAA,EAAA;AAAA,sBAAA,IAAA,SAAA,CAAA,mCAAA,CAAA;AAAA;AAAA;AAEA;;;;;;;;;AAQA,gBAAA,MAAA,GAAA;AACA,cAAA,OAAA,EAAA,OADA;AAEA,cAAA,MAAA,EAAA,MAFA;+EAAA;AAIA,cAAA,QAAA,EAAA,IAJA;AAKA,cAAA,KAAA,EAAA;AALA,aAAA;AAQA;;;;;AAKA,gBAAA,UAAA,GAAA,YAAA;;;;;;;;;AASA,oBAAA,KAAA,GAAA,IAAA;;;AAGA,oBAAA,OAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,EAAA;;AAEA,gBAAA,eAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AAEA,qBAAA,MAAA,GAAA,MAAA;AAEA,oBAAA,GAAA,GAAA,KAAA;AACA,oBAAA,iBAAA,GAAA,EAAA;;AAEA,qBAAA,IAAA,GAAA,IAAA,QAAA,EAAA;AACA,sBAAA,QAAA,CAAA,cAAA,CAAA,GAAA,CAAA,EAAA;AACA,wBAAA,OAAA,CAAA,OAAA,EAAA;AACQ,sBAAA,iBAAA,CAAA,GAAA,GAAA,KAAA,CAAA,GAAA,IAAA,CADR,CACQ;AACR;;AACA,oBAAA,GAAA,GAAA,GAAA,IAAA,iBAAA,CAAA,GAAA,GAAA,KAAA,CAAA;AACQ;AACF;;AAEN,oBAAA,GAAA,EAAA;AACA,uBAAA,UAAA,GAAA,CAAA,GAAA,uBAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAA,iBAAA,EAAA,YAAA;AACA,2BAAA,KAAA,CAAA,cAAA,EAAA;mBADA,CAAA;AAGA,uBAAA,UAAA,GAAA,CAAA,GAAA,uBAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAA,iBAAA,EAAA,YAAA;AACA,2BAAA,KAAA,CAAA,cAAA,EAAA;AACA,mBAFA,CAAA;AAGA,iBAPA,MAOA;AACA,uBAAA,UAAA,GAAA,KAAA,cAAA;;;AAGA;AAEA;;;;;;;;;AASA,e;AAEA;;;;;;;AAOA,cAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAA,SAAA,OAAA,CAAA,GAAA,EAAA;;eAAA;AAIA;;;;;;;;AAQA,cAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,SAAA,cAAA,GAAA;AACA,oBAAA,KAAA,GAAA,KAAA,cAAA,EAAA;;AACA,oBAAA,KAAA,EAAgB;AAChB,uBAAA,MAAA,GAAA,KAAA,MAAA,CAAA,KAAA,CAAA,KAAA,CAAA,MAAA,CAAA;;;AAGA,eANA;AAQA;;;;;;;AAOA,cAAA,UAAA,CAAc,SAAd,CAAc,cAAd,GAAc,SAAA,cAAA,GAAA;AACd,qBAAA,IAAA,IAAA,IAAA,MAAA,EAAA;AACA,sBAAA,MAAA,CAAA,cAAA,CAAA,IAAA,CAAA,EAAA;AACA,wBAAA,MAAA,CAAA,IAAA,CAAA,CAAA,IAAA,CAAA,KAAA,MAAA,CAAA,EAAA;AACA,0BAAA,KAAA,GAAA,aAAA,CAAA,IAAA,CAAA,CAAA,KAAA,MAAA,CAAA;;AAEA,0BAAA,KAAA,EAAA;AACA,4BAAA,KAAA,CAAA,IAAA,KAAA,UAAA,IAAA,gBAAA,IAAA,CAAA,KAAA,CAAA,OAAA,CAAA,EAAA;AACA,iCAAA,IAAA;yBADA,M;AAGA,0BAAA,KAAA,CAAA,IAAA,GAAA,KAAA,MAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,CAAA,MAAA,CAAA;AACA,iCAAA,KAAA;AACA;AACA;AACA;AACA;AACA;eAhBA;AAmBA;;;;;;;;;AASA,cAAA,UAAA,CAAA,SAAA,CAAgB,SAAhB,GAAgB,SAAA,SAAA,GAAA;AAChB,uBAAA,KAAA,UAAA,EAAA;eADA;AAIA;;;;;;;;;;;AAWA,e;AAEA;;;;;;;;AAQA,oBAAA,GAAA,GAAA,KAAA,CAAA;;AACA,uBAAA,GAAA,GAAA,KAAA,SAAA,EAAA,EAAA;AACA;AACA,sBAAA,QAAgB,CAAA,GAAO,CAAA,IAAP,CAAhB,IAAuB,QAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA,GAAA,MAAA,KAAvB,EAAuB;AACvB;;;AAGA,e;AAEA;;;;;;;AAOA,cAAA,UAAA,CAAA,SAAA,CAAuB,KAAvB,GAAuB,SAAA,KAAA,GAAA;AACvB,oBAAA,IAAA,GAAA,KAAA,MAAA;;;AAGA,eAJA;AAMA;;;;;;;;AAQA,uBAAA,KAAA,MAAA;AACA,e;;;AAGA,aA/KA,EAAA;;;;AAoLA,YAAA,UAAA,CAAA,aAAA,GAAA,UAAA,GAAA,EAAA;AACA,qBAAA,GAAA,CAAA,QAAA,EAAA;AACA,aAFA;;AAIA,YAAA,UAAA,CAAA,gBAAA,GAAA,UAAA,KAAA,EAAA;AACA,kBAAA,YAAA,GAAA,EAAA;;AAEA,mBAAA,IAAA,IAAA,IAAA,KAAA,EAAA;;AAEA,kBAAA,YAAA,CAAA,IAAA,CAAA,GAAA,CAAA,GAAA,MAAA,CAAA,YAAA,EAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,CAAA;AACA;AACA;;AAEA,qBAAA,YAAA;aATA;;AAYA,YAAA,UAAA,CAAA,QAAA,GAAA,QAAA;;;AAGA,kBAAA,QAAA,CAAA,cAAA,CAAA,GAAA,CAAA,EAAA;;AAEA;AACA;;;;AAGA;;;;AAGA;;AAEA,YAAA,OAAA,CAAA,UAAA,GAAA,IAAA;AACA,gBAAE,OAAA,GAAA,KAAF;AACA,gBAAA,SAAA,GAAA,KAAA;;;AAIA,gBAAA;AACA,kBAAA,IAAA,GAAA,gBAAA;AACE,cAAA,IAAA,CAAA,SAAA,GAAA,IAAA;AACF,cAAA,OAAA,CAAA,OAAA,GAAA,OAAA,GAAA,IAAA,CAAA,SAAA,KAAA,IAAA;AACA,aAJA,CAIA,OAAA,CAAA,EAAA;;AAEA;;AAEA,gBAAA;AACA,cAAA,IAAA,CAAA,SAAA,GAAA,uBAAA;;AAEA,aAHA,CAGA,OAAO,CAAP,EAAO;AACP,cAAA,OAAA,CAAA,SAAA,GAAA,SAAA,GAAA,KAAA;AACA;;AAEA,YAAA,IAAA,GAAA,IAAA;AAEA,YAAA,OAAA,CAAA,OAAA,GAAA,OAAA;;;;AAIA;;AACA;AAAA,oBAAA,MAAA,EAAA,OAAA,EAAA,mBAAA,EAAA;AAEA;;;;;;;;;;AAMA,YAAA,OAAA,CAAA,OAAA,GAAA,OAAA;AACA,YAAA,OAAA,CAAA,KAAA,GAAA,KAAA;AACA,YAAA,OAAA,CAAA,QAAA,GAAW,QAAX;AACA,YAAA,OAAA,CAAA,SAAA,GAAA,SAAA;AACA,YAAA,OAAA,CAAA,MAAA,GAAA,MAAA;;AAEA,gBAAA,OAAA,GAAA,mBAAA,CAAA,CAAA,CAAA;AAEA;;;;;;;AAKA,gBAAA,OAAA,GAAA;AACA,cAAA,QAAA,EAAY,+FADZ;AAEA,cAAA,MAAA,EAAA,6BAFA;AAGA,cAAA,IAAA,EAAA,qHAHA;AAIA,cAAA,QAAA,EAAA;AAJA,aAAA;AAOA;;;;;;;AAMA,qBAAA,OAAA,CAAA,MAAA,EAAA;AACA,kBAAA,KAAY,GAAA,MAAO,CAAA,OAAP,CAAO,KAAP,CAAZ;;AACA,kBAAA,KAAA,IAAc,CAAd,EAAc;AACd,uBAAA,IAAA,OAAA,CAAA,YAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,GAAA,CAAA,CAAA,EAAA,KAAA,GAAA,CAAA,CAAA;AACA;AACA;AAEA;;;;;;;;AAMA,qBAAA,KAAA,CAAc,MAAd,EAAc;AACd,kBAAA,KAAA,GAAA,MAAA,CAAA,OAAA,CAAA,GAAA,CAAA;AACA,qBAAA,IAAA,OAAA,CAAA,UAAA,CAAA,KAAA,IAAA,CAAA,GAAA,KAAA,GAAA,MAAA,CAAA,MAAA,CAAA;AACA;AAEA;;;;;;;;;AAOA,kBAAA,WAAA,GAAA,MAAA,CAAA,OAAA,CAAA,GAAA,CAAA;;AACA,kBAAA,WAAA,KAAA,CAAA,CAAA,EAAA;AACA,oBAAA,KAAA,GAAA,MAAA,CAAA,KAAA,CAAA,OAAA,CAAA,QAAA,CAAA;;AACA,oBAAA,KAAA,EAAY;AACZ,sBAAA,IAAA,GAAA,YAAA;AACA,wBAAA,KAAA,GAAA,EAAA;AACA,wBAAY,YAAA,GAAA,EAAZ;AACA,wBAAA,IAAA,GAAA,KAAA,CAAA,CAAA,CAAA;;AAGA,0BAAA,EAAA,SAAA,CAAA,CAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,CAAA,EAAA;AACU,wBAAA,KAAA,CAAA,IAAA,CAAA,GAAA,EAAA;uBADV,M;AAGA,wBAAA,KAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,GAAA,EAAA;AACA,wBAAA,YAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,GAAA,IAAA;AACA,uB,MAAA;AACQ,wBAAA,KAAA,CAAA,IAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,IAAA,OAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA,KAAA,IAAA,IAAA,EAAA;;;AAGR,sBAAA,IAAA,GAAA,IAAA,CAAA,OAAA,CAAA,KAAA,EAAA,EAAA,CAAA;AACA,qB;;AAGA,sBAAA,CAAA,EAAA,IAAA,OAAA,CAAA,aAAA,CAAA,KAAA,CAAA,CAAA,CAAA,EAAA,KAAA,CAAA,CAAA,CAAA,CAAA,MAAA,EAAA,KAAA,EAAA,YAAA,EAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,EAAA,IAAA,CAAA,OAAA,CAAA,oCAAA,EAAA,EAAA,CAAA;;AAEA,mBArBA,EAAA;;AAuBA,sBAAA,CAAA,OAAc,IAAd,KAAc,WAAd,GAAc,WAAd,GAAc,OAAA,CAAA,IAAA,CAAd,MAAc,QAAd,EAAc,OAAA,IAAA,CAAA,CAAA;AACd;AACA;AACA;AAEA;;;;;;;;AAMA,qBAAA,SAAA,CAAA,MAAA,EAAA;AACA,kBAAA,KAAA,GAAA,QAAA,CAAA,MAAA,CAAA;;AACA,kBAAA,KAAA,EAAA;AACA,oBAAA,IAAA,GAAA,MAAA,CAAA,KAAA,CAAA,KAAA,CAAA,MAAA,CAAA,CADA,CAEA;;;AAEA;AACA,sBAAA,KAAA,GAAA,IAAA,CAAA,KAAA,CAAA,IAAA,MAAA,CAAA,wBAAA,KAAA,CAAA,OAAA,GAAA,OAAA,EAAA,GAAA,CAAA,CAAA;;AACA,sBAAA,KAAA,EAAA;AACA,2BAAY,IAAO,OAAA,CAAA,cAAP,CAAO,KAAA,CAAA,OAAP,EAAO,KAAA,CAAA,CAAA,CAAA,CAAA,MAAA,GAAA,KAAA,CAAA,MAAP,EAAO,KAAA,CAAA,KAAP,EAAO,KAAA,CAAA,YAAP,EAAO,KAAA,CAAA,CAAA,CAAP,CAAZ;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAMA,qBAAA,MAAA,CAAA,MAAA,EAAA;;;AAEA,kBAAA,KAAA,EAAA;;AAEA;AACA;AAEA;;AAAA,W;;;AAEA;AAAA,oBAAA,MAAA,EAAA,OAAA,EAAA,mBAAA,EAAkD;AAElD;;AAEA,YAAA,OAAA,CAAA,UAAA,GAAA,IAAA;AACA,YAAA,OAAA,CAAA,WAAA,GAAA,OAAA,CAAA,cAAA,GAAA,OAAA,CAAA,aAAA,GAAA,OAAA,CAAA,QAAA,GAAA,OAAA,CAAA,UAAA,GAAA,OAAA,CAAA,YAAA,GAAA,OAAA,CAAA,KAAA,GAAA,SAAA;;AAEA,gBAAA,MAAA,GAAA,mBAAA,CAAA,CAAA,CAAA;;AAEA,qBAAA,eAAA,CAAA,QAAA,EAAA,WAAA,EAAA;AAAA,kBAAA,EAAA,QAAA,YAAA,WAAA,CAAA,EAAA;AAAA,sBAAA,IAAA,SAAA,CAAA,mCAAA,CAAA;AAAA;AAAA;AAEA;;;;;;;AAKA;;;;;;AAMA,YAAA,OAAA,CAAA,KAAA,GAAA,SAAA,KAAA,CAAA,IAAA,EAAA,MAAA,EAAA;AACA,cAAA,eAAA,CAAA,IAAA,EAAA,KAAA,CAAA;;;AAGA,mBAAA,MAAA,GAAA,MAAA;AACA,mBAAA,IAAA,GAAA,EAAA;AACA,a;AAEA;;;;;;AAMA;;;;;;AAMA,uBAAA,YAAA,CAAA,OAAA,EAAA,MAAA,EAAA;AACA,gBAAA,eAAA,CAAA,IAAA,EAAA,YAAA,CAAA;;;AAGA,qBAAA,MAAA,GAAA,MAAA,KAAA,OAAA,GAAA,OAAA,CAAA,MAAA,GAAA,CAAA,CAAA;AACE,qBAAA,IAAA,GAAA,EAAA;;AAEF;;AAEA,cAAA,YAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAA,QAAA,GAAA;;eAAA;;AAIA,qBAAA,YAAA;AACA,a;AAEA;;;;;AAKA,gBAAA,UAAA,GAAA,OAAA,CAAA,UAAA,GAAA,YAAA;AACA;;;;;AAKA,uBAAA,UAAA,CAAA,MAAA,EAAA;AACA,gBAAA,eAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AAEA,qBAAA,IAAA,GAAA,OAAA;AACE,qBAAA,MAAA,GAAA,MAAA;;AAEF;;AAEA,cAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAA,QAAA,GAAA;;eAAA;;AAIA,qBAAA,UAAA;AACA,aAnBA,EAAA;AAqBA;;;;;AAKA,gBAAA,QAAA,GAAA,OAAA,CAAA,QAAA,GAAA,YAAA;AACA;;;;;;;;;;AAUA,uBAAA,QAAA,CAAA,IAAA,EAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAAA,YAAA,EAAA;AACA,gBAAA,eAAA,CAAA,IAAA,EAAA,QAAA,CAAA;;;AAGA,qBAAA,MAAA,GAAA,MAAA;AACA,qBAAA,IAAA,GAAA,EAAA;AACA,qBAAA,OAAA,GAAA,OAAA;AACA,qBAAA,KAAA,GAAc,KAAd;AACA,qBAAA,YAAA,GAAsB,YAAtB;AACA,qBAAA,KAAA,GAAgB,KAAhB;AACA,qBAAA,UAAA,GAAA,KAAA;;AAGA;;;;;;;;;AASA,cAAA,QAAA,CAAA,SAAA,GAAA,SAAA,SAAA,CAAA,GAAA,EAAA;AACA,oBAAA,OAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,IAAA;AAEA,oBAAA,GAAA,GAAA,MAAA,GAAA,CAAA,OAAA;;AACA,qBAAA,IAAA,GAAA,IAAA,GAAA,CAAA,KAAA,EAAA;;AAEA,oBAAA,GAAA,IAAA,MAAA,GAAA;AAEA,wBAAA,GAAA,GAAA,GAAA,CAAA,KAAA,CAAA,GAAA,CAAA;;;AAEA,sBAAA,GAAA,IAAA,OAAA,CAAA,GAAA,MAAA,CAAA,YAAA,EAAA,GAAA,CAAA,GAAA,GAAA;AACA;AACM;AACN;;;AAGA,kBAAA,GAAA,IAAA,MAAA,GAAA,CAAA,IAAA;AACA;;;AAGA,kBAAA,GAAA,IAAA,IAAA;AACA,iB,MAAA;;AAEA;;;AAGA,kBAAA,GAAA,IAAA,OAAA,GAAA,IAAA,GAAA,GAAA,CAAA,OAAA,GAAA,GAAA;AACA;;;eA3BA;;AAgCA,qBAAA,QAAA;AACA,aAlEA,EAAA;AAoEA;;;;;AAKA,gBAAA,aAAc,GAAA,OAAQ,CAAA,aAAR,GAAQ,YAAA;AACtB;;;;;;;;;;;AAWA,uBAAA,aAAA,CAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAAA,YAAA,EAAA,KAAA,EAAA,IAAA,EAAA;AACA,gBAAA,eAAA,CAAA,IAAA,EAAA,aAAA,CAAA;;AAEA,qBAAA,IAAA,GAAA,UAAA;;AAEA,qBAAA,IAAA,GAAA,EAAA;AACA,qBAAA,OAAA,GAAA,OAAA;AACA,qBAAA,KAAA,GAAA,KAAA;;AAEA,qBAAA,UAAA,GAAA,KAAA;AACE,qBAAA,KAAA,GAAA,KAAA;;AAEF;;AAEA,cAAA,aAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAA,QAAA,GAAA;;eAAA;;AAIA,qBAAA,aAAA;AACA,aA/BsB,EAAtB;AAiCA;;;;;AAKA,gBAAA,cAAc,GAAO,OAAA,CAAA,cAAA,GAAA,YAAA;AACrB;;;;;;;;;;AAUA,uBAAA,cAAA,CAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAAA,YAAA,EAAA,OAAA,EAAA;AACA,gBAAA,eAAA,CAAA,IAAA,EAAA,cAAA,CAAA;;AAEA,qBAAA,IAAA,GAAA,WAAA;;AAEA,qBAAA,IAAA,GAAA,EAAA;AACA,qBAAA,OAAA,GAAA,OAAA;AACA,qBAAA,KAAA,GAAA,KAAA;;AAEA,qBAAA,KAAA,GAAA,KAAA;AACE,qBAAA,UAAA,GAAA,KAAA;;AAEF;;AAEA,cAAA,cAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAA,QAAA,GAAA;;eAAA;;AAIA,qBAAA,cAAA;AACA,aA9BqB,EAArB;AAgCA;;;;;;AAMA;;;;;;AAMA,uBAAA,WAAA,CAAA,OAAA,EAAA,MAAA,EAAA;AACA,gBAAA,eAAA,CAAA,IAAA,EAAA,WAAA,CAAA;;;AAGA,qBAAA,MAAA,GAAA,MAAA;AACE,qBAAA,IAAA,GAAA,EAAA;;AAEF;;AAEA,cAAA,WAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAA,QAAA,GAAA;;AAEA,eAFA;;AAIA,qBAAA,WAAA;AACA,a;AAEA;;AAAA,W;AACA;;AACA;AAAA,oBAAA,MAAA,EAAA,OAAA,EAAA;AAEA;;AAEA,YAAA,OAAA,CAAA,UAAA,GAAA,IAAA;AACA,YAAA,OAAA,CAAA,YAAA,GAAA,YAAA;;;;;;;;;AASA,qBAAA,YAAA,CAAA,KAAA,EAAA;wGAAA,CAGA;AACA;;;AAEA,uBAAA,KAAA,IAAA,CAAA,MAAA,IAAA,MAAA,GAAA,GAAA,GAAA,MAAA,GAAA,KAAA;AAEA,e;AACA;AAEA;;AAAA,W;AACA;;AACA;AAAA,oBAAW,MAAX,EAAW,OAAX,EAAW;AAEX;;AAEA,YAAA,OAAA,CAAA,UAAA,GAAA,IAAA;AACA,YAAA,OAAA,CAAA,SAAA,CAAA,GAAA,qBAAA;AACA;;;;;;AAKA,gBAAA,KAAA,GAAA,iFAAA;AAEA;;;;;;AAKA,gBAAA,SAAA,GAAA,uDAAA;AAEA;;;;;;;AAMA,qBAAA,OAAA,CAAA,GAAA,EAAA;AACA,kBAAA,GAAA,IAAA,GAAA,CAAA,IAAA,KAAA,UAAA,EAAA;AACA,gBAAA,GAAA,CAAA,KAAA,GAAY,KAAA,CAAW,IAAX,CAAW,GAAA,CAAA,OAAX,KAAW,GAAA,CAAA,KAAvB;AACA,gBAAA,GAAA,CAAA,UAAA,GAAqB,CAAA,OAAA,IAAA,CAAA,GAAA,CAAA,IAAA,CAArB;AACA;;AACA,qBAAA,GAAA;AACA;AAEA;;;;;;;;;AAOA,qBAAA,SAAA,CAAA,MAAA,EAAA,aAAA,EAAA;AACA,kBAAA,GAAA,GAAY,MAAA,CAAA,MAAZ;AACA,kBAAA,GAAA,GAAY,OAAA,CAAA,aAAa,EAAb,CAAZ;AACA,cAAA,MAAA,CAAA,MAAA,GAAA,GAAA;AACA,qBAAA,GAAA;AACA;AAEA;;;;;;;;AAMA,qBAAA,SAAA,CAAA,MAAA,EAAA,KAAA,EAAA;AACA,kBAAA,GAAA,GAAA,KAAc,CAAA,GAAd,EAAA,CADA,CAGA;;AACA,cAAA,MAAA,CAAA,OAAA,CAAA,OAAA,GAAA,CAAA,OAAA,GAAA,GAAA;;AAGA;;;;;;;AAKA,qBAAA,QAAA,GAAA;AACA,kBAAA,KAAA,GAAA,EAAA;;AAEA,cAAA,KAAA,CAAA,IAAA,GAAA,YAAA;AACA,uBAAA,KAAA,KAAA,MAAA,GAAyB,CAAzB,CAAA;AACA,eAFA;;AAIA,cAAA,KAAA,CAAA,aAAA,GAAA,UAAA,OAAA,EAAA;AACA,oBAAA,IAAA,GAAA,KAAA,IAAA,EAAA;AACA,uBAAA,IAAA,IAAA,IAAA,CAAA,OAAA,IAAA,IAAA,CAAA,OAAA,CAAA,WAAA,OAAA,OAAA,CAAA,WAAA,EAAA;AACA,eAHA;;AAKA,cAAA,KAAA,CAAA,eAAA,GAAA,UAAA,OAAA,EAAA;AACA,qBAAA,IAAA,CAAA,GAAA,CAAA,EAAA,GAAA,EAAA,GAAA,GAAA,KAAA,CAAA,CAAA,EAAA,CAAA,EAAA,EAAA;;AAEA,2BAAA,IAAA;AACA;AACA;;AACA,uBAAY,KAAZ;AACA,eAPA;;AASA,qBAAA,KAAA;AACA;AAEA;;;;;;;;;;;;AAUA,qBAAA,qBAAA,CAAA,MAAA,EAAA,OAAA,EAAA,aAAA,EAAA;AACA,kBAAA,KAAQ,GAAA,QAAA,EAAR;AAEA,kBAAA,QAAA,GAAA;AACA,gBAAA,QAAU,EAAA,SAAA,QAAA,CAAA,GAAA,EAAA;AACV,sBAAA,OAAA,GAAA,GAAA,CAAA,OAAA;;AAEA,sBAAA,OAAA,CAAA,WAAA,OAAA,IAAA,IAAA,KAAA,CAAA,aAAA,CAAA,OAAA,CAAA,EAAA;AACQ,oBAAA,MAAA,CAAA,OAAA,CAAA,SAAA;AACR,oBAAA,gBAAA;AACA,mBAHA,MAGA,IAAA,OAAA,CAAA,YAAA,IAAA,SAAA,CAAA,IAAA,CAAA,OAAA,CAAA,IAAA,KAAA,CAAA,eAAA,CAAA,OAAA,CAAA,EAAA;AACM,wBAAA,KAAA,CAAA,aAAA,CAAA,OAAA,CAAA,EAAA;AACN,sBAAA,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA;AACA,qBAFM,MAEN;AACA,sBAAA,MAAA,CAAA,OAAA,CAAA,OAAA,GAAA,CAAA,OAAA,GAAA,GAAA;AACA,sBAAA,gBAAA;AACA;AACA,mBAPA,MAOA,IAAA,CAAA,GAAA,CAAA,KAAA,EAAA;AACA,oBAAA,KAAU,CAAA,IAAV,CAAU,GAAV;AACA;AACA,iBAjBA;AAkBA,gBAAA,MAAQ,EAAA,SAAA,MAAA,CAAA,GAAA,EAAA;AACR,sBAAA,IAAA,GAAA,KAAA,CAAA,IAAA,EAAA;;AACA,sBAAA,IAAA,EAAA;AACA,wBAAA,OAAA,CAAA,UAAA,IAAA,CAAA,KAAA,CAAA,aAAA,CAAA,GAAA,CAAA,OAAA,CAAA,EAAA;AACA;AACA,sBAAA,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA;AACA,qBAHA,MAGA;;AAEA;AACA,mBAPA,MAOA,IAAA,OAAA,CAAA,UAAA,EAAA;AACA;AACA,oBAAA,aAAA;AACA,oBAAA,gBAAA;AACA;;AA/BA,eAAA;;AAmCA,uBAAA,gBAAA,GAAA;AACA,oBAAA,GAAA,GAAA,SAAA,CAAA,MAAA,EAAA,aAAA,CAAA;;AACA,oBAAA,GAAA,IAAA,QAAA,CAAA,GAAA,CAAA,IAAA,CAAA,EAAA;;AAEA;AACA;;;;;;;;;;;WAt4BA;AAAA;OAVA;;;;;ACZgBC;;;AAUAC,cAAAA,MAAAA,EAAAA,OAAAA,E;AA0BAC;;cA+BAC,U,GAAAA,I;;UA6BAC,OAAAA,GAAAA,O,MAAAA,K,UAAAA,I,mCAAAA,G;;OAAAA,G;;;;cAsBAE,M,GAAAA,M;AA5HhB,MAAA,OAAA,CAAA,UAAA,GAAA,UAAA;;;;;;AAMO,MAAA,OAAA,CAAA,KAAA,GAAA,KAAA;AACL,MAAA,OAAA,CAAA,QAAA,GAAA,QAAA;AACD,MAAA,OAAA,CAAA,OAAA,GAAA,OAAA;;;;;;;;;AAQM,eAASL,KAAAA,KAAT,KAAuB,CAAdA,IAAc,KAAA,KAAA,IAAvB;AACL;;;;;;;;;;;AAUK;AAEL;;;;;;;;;;;;;;;;AAaK;AAEH;;;;;;;;;;;;;;;AAaG;AAELC;;;;;;;;;;AAQF,QAAA,OAAA,GAAA,OAAA,IAAA,EAAA;;;;;;AAMO,eAAA,OAAA;AACL;AAAA;;;;;;;;AAOE,eAAA,OAAA,CAAA,GAAA,EAAA;AAAA,YAAA;AAAA,iBAAA,KAAA,CAAA,SAAA,CAAA,KAAA,CAAA,IAAA,CAAA,GAAA,CAAA;AALU,SAKV,CALU,OAAA,CAAA,EAAA;;AAAA,gBAAA,GAAA,GAAA,EAAA;AAMX,YAAA,IAAA,CAAA,GAAA,EAAA,UAAA,GAAA,EAAA;AACF,cAAA,GAAA,CAAA,IAAA,CAAA,GAAA;aADE,CAAA;AAGH,mBAAA;;AAAA,aAAA;;;;AAMO;AACL;;;;;;;;;;;AAUK;AAIN;;;;;;;;;;AAQM,eAASG,CAAAA,GAAAA,IAAT,EAAA,GAAA,CAAuB,IAAvB,KAAuB,UAAvB,IAAuB,GAAA,CAAA,IAAA,KAAA,WAAvB,CAASA,IAAc,EAAA,aAAA,GAAA,CAAdA,GAAc,CAAA,CAAdA,GAAc,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,WAAA,GAAA,OAAA,CAAA,GAAA,CAAvB;AACL;;;;;;;;;;AASK,eAASC,KAAAA,CAAT,GAASA,EAAT,QAASA,CAAT;AACL;;;;;;;;;;;;;;;;KLrHF;AAAA;CDCA","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postscribe\"] = factory();\n\telse\n\t\troot[\"postscribe\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c9988e4825e1b6d62704","import postscribe from './postscribe';\n\nmodule.exports = postscribe;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","import WriteStream from './write-stream';\nimport * as utils from './utils';\n\n/**\n * A function that intentionally does nothing.\n */\nfunction doNothing() {\n}\n\n/**\n * Available options and defaults.\n *\n * @type {Object}\n */\nconst OPTIONS = {\n  /**\n   * Called when an async script has loaded.\n   */\n  afterAsync: doNothing,\n\n  /**\n   * Called immediately before removing from the write queue.\n   */\n  afterDequeue: doNothing,\n\n  /**\n   * Called sync after a stream's first thread release.\n   */\n  afterStreamStart: doNothing,\n\n  /**\n   * Called after writing buffered document.write calls.\n   */\n  afterWrite: doNothing,\n\n  /**\n   * Allows disabling the autoFix feature of prescribe\n   */\n  autoFix: true,\n\n  /**\n   * Called immediately before adding to the write queue.\n   */\n  beforeEnqueue: doNothing,\n\n  /**\n   * Called before writing a token.\n   *\n   * @param {Object} tok The token\n   */\n  beforeWriteToken: tok => tok,\n\n  /**\n   * Called before writing buffered document.write calls.\n   *\n   * @param {String} str The string\n   */\n  beforeWrite: str => str,\n\n  /**\n   * Called when evaluation is finished.\n   */\n  done: doNothing,\n\n  /**\n   * Called when a write results in an error.\n   *\n   * @param {Error} e The error\n   */\n  error(e) { throw new Error(e.msg); },\n\n  /**\n   * Whether to let scripts w/ async attribute set fall out of the queue.\n   */\n  releaseAsync: false\n};\n\nlet nextId = 0;\nlet queue = [];\nlet active = null;\n\nfunction nextStream() {\n  const args = queue.shift();\n  if (args) {\n    const options = utils.last(args);\n\n    options.afterDequeue();\n    args.stream = runStream(...args);\n    options.afterStreamStart();\n  }\n}\n\nfunction runStream(el, html, options) {\n  active = new WriteStream(el, options);\n\n  // Identify this stream.\n  active.id = nextId++;\n  active.name = options.name || active.id;\n  postscribe.streams[active.name] = active;\n\n  // Override document.write.\n  const doc = el.ownerDocument;\n\n  const stash = {\n    close: doc.close,\n    open: doc.open,\n    write: doc.write,\n    writeln: doc.writeln\n  };\n\n  function write(str) {\n    str = options.beforeWrite(str);\n    active.write(str);\n    options.afterWrite(str);\n  }\n\n  Object.assign(doc, {\n    close: doNothing,\n    open: doNothing,\n    write: (...str) => write(str.join('')),\n    writeln: (...str) => write(str.join('') + '\\n')\n  });\n\n  // Override window.onerror\n  const oldOnError = active.win.onerror || doNothing;\n\n  // This works together with the try/catch around WriteStream::insertScript\n  // In modern browsers, exceptions in tag scripts go directly to top level\n  active.win.onerror = (msg, url, line) => {\n    options.error({msg: `${msg} - ${url}: ${line}`});\n    oldOnError.apply(active.win, [msg, url, line]);\n  };\n\n  // Write to the stream\n  active.write(html, () => {\n    // restore document.write\n    Object.assign(doc, stash);\n\n    // restore window.onerror\n    active.win.onerror = oldOnError;\n\n    options.done();\n    active = null;\n    nextStream();\n  });\n\n  return active;\n}\n\nexport default function postscribe(el, html, options) {\n  if (utils.isFunction(options)) {\n    options = {done: options};\n  } else if (options === 'clear') {\n    queue = [];\n    active = null;\n    nextId = 0;\n    return;\n  }\n\n  options = utils.defaults(options, OPTIONS);\n\n  // id selector\n  if ((/^#/).test(el)) {\n    el = window.document.getElementById(el.substr(1));\n  } else {\n    el = el.jquery ? el[0] : el;\n  }\n\n  const args = [el, html, options];\n\n  el.postscribe = {\n    cancel: () => {\n      if (args.stream) {\n        args.stream.abort();\n      } else {\n        args[1] = doNothing;\n      }\n    }\n  };\n\n  options.beforeEnqueue(args);\n  queue.push(args);\n\n  if (!active) {\n    nextStream();\n  }\n\n  return el.postscribe;\n}\n\nObject.assign(postscribe, {\n  // Streams by name.\n  streams: {},\n  // Queue of streams.\n  queue,\n  // Expose internal classes.\n  WriteStream\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/postscribe.js","import HtmlParser from 'prescribe';\nimport * as utils from './utils';\n\n/**\n * Turn on to debug how each chunk affected the DOM.\n * @type {boolean}\n */\nconst DEBUG_CHUNK = false;\n\n/**\n * Prefix for data attributes on DOM elements.\n * @type {string}\n */\nconst BASEATTR = 'data-ps-';\n\n/**\n * ID for the style proxy\n * @type {string}\n */\nconst PROXY_STYLE = 'ps-style';\n\n/**\n * ID for the script proxy\n * @type {string}\n */\nconst PROXY_SCRIPT = 'ps-script';\n\n/**\n * Get data attributes\n *\n * @param {Object} el The DOM element.\n * @param {String} name The attribute name.\n * @returns {String}\n */\nfunction getData(el, name) {\n  const attr = BASEATTR + name;\n\n  const val = el.getAttribute(attr);\n\n  // IE 8 returns a number if it's a number\n  return !utils.existy(val) ? val : String(val);\n}\n\n/**\n * Set data attributes\n *\n * @param {Object} el The DOM element.\n * @param {String} name The attribute name.\n * @param {null|*} value The attribute value.\n */\nfunction setData(el, name, value = null) {\n  const attr = BASEATTR + name;\n\n  if (utils.existy(value) && value !== '') {\n    el.setAttribute(attr, value);\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\n/**\n * Stream static html to an element, where \"static html\" denotes \"html\n * without scripts\".\n *\n * This class maintains a *history of writes devoid of any attributes* or\n * \"proxy history\".\n *\n * Injecting the proxy history into a temporary div has no side-effects,\n * other than to create proxy elements for previously written elements.\n *\n * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to\n * `proxy_history + staticHtml`.\n * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes\n * beside or inside of proxy elements), reflects the DOM structure that would\n * have resulted if all writes had been squashed into a single write.\n *\n * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,\n * `node` is appended to the corresponding *real* element within the DOM.\n *\n * Proxy elements are mapped to *actual* elements in the DOM by injecting a\n * `data-id` attribute into each start tag in `staticHtml`.\n *\n */\nexport default class WriteStream {\n  /**\n   * Constructor.\n   *\n   * @param {Object} root The root element\n   * @param {?Object} options The options\n   */\n  constructor(root, options = {}) {\n    this.root = root;\n    this.options = options;\n    this.doc = root.ownerDocument;\n    this.win = this.doc.defaultView || this.doc.parentWindow;\n    this.parser = new HtmlParser('', {autoFix: options.autoFix});\n\n    // Actual elements by id.\n    this.actuals = [root];\n\n    // Embodies the \"structure\" of what's been written so far,\n    // devoid of attributes.\n    this.proxyHistory = '';\n\n    // Create a proxy of the root element.\n    this.proxyRoot = this.doc.createElement(root.nodeName);\n\n    this.scriptStack = [];\n    this.writeQueue = [];\n\n    setData(this.proxyRoot, 'proxyof', 0);\n  }\n\n  /**\n   * Writes the given strings.\n   *\n   * @param {...String} str The strings to write\n   */\n  write(...str) {\n    this.writeQueue.push(...str);\n\n    // Process writes\n    // When new script gets pushed or pending this will stop\n    // because new writeQueue gets pushed\n    while (!this.deferredRemote && this.writeQueue.length) {\n      const arg = this.writeQueue.shift();\n\n      if (utils.isFunction(arg)) {\n        this._callFunction(arg);\n      } else {\n        this._writeImpl(arg);\n      }\n    }\n  }\n\n  /**\n   * Calls the given function.\n   *\n   * @param {Function} fn The function to call\n   * @private\n   */\n  _callFunction(fn) {\n    const tok = {type: 'function', value: fn.name || fn.toString()};\n    this._onScriptStart(tok);\n    fn.call(this.win, this.doc);\n    this._onScriptDone(tok);\n  }\n\n  /**\n   * The write implementation\n   *\n   * @param {String} html The HTML to write.\n   * @private\n   */\n  _writeImpl(html) {\n    this.parser.append(html);\n\n    let tok;\n    let script;\n    let style;\n    const tokens = [];\n\n    // stop if we see a script token\n    while ((tok = this.parser.readToken()) &&\n      !(script = utils.isScript(tok)) &&\n      !(style = utils.isStyle(tok))) {\n      tok = this.options.beforeWriteToken(tok);\n\n      if (tok) {\n        tokens.push(tok);\n      }\n    }\n\n    if (tokens.length > 0) {\n      this._writeStaticTokens(tokens);\n    }\n\n    if (script) {\n      this._handleScriptToken(tok);\n    }\n\n    if (style) {\n      this._handleStyleToken(tok);\n    }\n  }\n\n  /**\n   * Write contiguous non-script tokens (a chunk)\n   *\n   * @param {Array<Object>} tokens The tokens\n   * @returns {{tokens, raw, actual, proxy}|null}\n   * @private\n   */\n  _writeStaticTokens(tokens) {\n    const chunk = this._buildChunk(tokens);\n\n    if (!chunk.actual) {\n      // e.g., no tokens, or a noscript that got ignored\n      return null;\n    }\n\n    chunk.html = this.proxyHistory + chunk.actual;\n    this.proxyHistory += chunk.proxy;\n    this.proxyRoot.innerHTML = chunk.html;\n\n    if (DEBUG_CHUNK) {\n      chunk.proxyInnerHTML = this.proxyRoot.innerHTML;\n    }\n\n    this._walkChunk();\n\n    if (DEBUG_CHUNK) {\n      chunk.actualInnerHTML = this.root.innerHTML;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * Build a chunk.\n   *\n   * @param {Array<Object>} tokens The tokens to use.\n   * @returns {{tokens: *, raw: string, actual: string, proxy: string}}\n   * @private\n   */\n  _buildChunk(tokens) {\n    let nextId = this.actuals.length;\n\n    // The raw html of this chunk.\n    const raw = [];\n\n    // The html to create the nodes in the tokens (with id's injected).\n    const actual = [];\n\n    // Html that can later be used to proxy the nodes in the tokens.\n    const proxy = [];\n\n    const len = tokens.length;\n    for (let i = 0; i < len; i++) {\n      const tok = tokens[i];\n      const tokenRaw = tok.toString();\n\n      raw.push(tokenRaw);\n\n      if (tok.attrs) { // tok.attrs <==> startTag or atomicTag or cursor\n        // Ignore noscript tags. They are atomic, so we don't have to worry about children.\n        if (!(/^noscript$/i).test(tok.tagName)) {\n          const id = nextId++;\n\n          // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'\n          actual.push(tokenRaw.replace(/(\\/?>)/, ` ${BASEATTR}id=${id} $1`));\n\n          // Don't proxy scripts: they have no bearing on DOM structure.\n          if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {\n            // Proxy: strip all attributes and inject proxyof attribute\n            proxy.push(\n              // ignore atomic tags (e.g., style): they have no \"structural\" effect\n              tok.type === 'atomicTag' ? '' :\n              `<${tok.tagName} ${BASEATTR}proxyof=${id}` + (tok.unary ? ' />' : '>')\n            );\n          }\n        }\n      } else {\n        // Visit any other type of token\n        // Actual: append.\n        actual.push(tokenRaw);\n\n        // Proxy: append endTags. Ignore everything else.\n        proxy.push(tok.type === 'endTag' ? tokenRaw : '');\n      }\n    }\n\n    return {\n      tokens,\n      raw: raw.join(''),\n      actual: actual.join(''),\n      proxy: proxy.join('')\n    };\n  }\n\n  /**\n   * Walk the chunks.\n   *\n   * @private\n   */\n  _walkChunk() {\n    let node;\n    const stack = [this.proxyRoot];\n\n    // use shift/unshift so that children are walked in document order\n    while (utils.existy(node = stack.shift())) {\n      const isElement = node.nodeType === 1;\n      const isProxy = isElement && getData(node, 'proxyof');\n\n      // Ignore proxies\n      if (!isProxy) {\n        if (isElement) {\n          // New actual element: register it and remove the the id attr.\n          this.actuals[getData(node, 'id')] = node;\n          setData(node, 'id');\n        }\n\n        // Is node's parent a proxy?\n        const parentIsProxyOf = node.parentNode &&\n          getData(node.parentNode, 'proxyof');\n        if (parentIsProxyOf) {\n          // Move node under actual parent.\n          this.actuals[parentIsProxyOf].appendChild(node);\n        }\n      }\n\n      // prepend childNodes to stack\n      stack.unshift.apply(stack, utils.toArray(node.childNodes));\n    }\n  }\n\n  /**\n   * Handles Script tokens\n   *\n   * @param {Object} tok The token\n   */\n  _handleScriptToken(tok) {\n    const remainder = this.parser.clear();\n\n    if (remainder) {\n      // Write remainder immediately behind this script.\n      this.writeQueue.unshift(remainder);\n    }\n\n    tok.src = tok.attrs.src || tok.attrs.SRC;\n\n    tok = this.options.beforeWriteToken(tok);\n    if (!tok) {\n      // User has removed this token\n      return;\n    }\n\n    if (tok.src && this.scriptStack.length) {\n      // Defer this script until scriptStack is empty.\n      // Assumption 1: This script will not start executing until\n      // scriptStack is empty.\n      this.deferredRemote = tok;\n    } else {\n      this._onScriptStart(tok);\n    }\n\n    // Put the script node in the DOM.\n    this._writeScriptToken(tok, () => {\n      this._onScriptDone(tok);\n    });\n  }\n\n  /**\n   * Handles style tokens\n   *\n   * @param {Object} tok The token\n   */\n  _handleStyleToken(tok) {\n    const remainder = this.parser.clear();\n\n    if (remainder) {\n      // Write remainder immediately behind this style.\n      this.writeQueue.unshift(remainder);\n    }\n\n    tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';\n\n    tok = this.options.beforeWriteToken(tok);\n\n    if (tok) {\n      // Put the style node in the DOM.\n      this._writeStyleToken(tok);\n    }\n\n    if (remainder) {\n      this.write();\n    }\n  }\n\n  /**\n   * Build a style and insert it into the DOM.\n   *\n   * @param {Object} tok The token\n   */\n  _writeStyleToken(tok) {\n    const el = this._buildStyle(tok);\n\n    this._insertCursor(el, PROXY_STYLE);\n\n    // Set content\n    if (tok.content) {\n      if (el.styleSheet && !el.sheet) {\n        el.styleSheet.cssText = tok.content;\n      } else {\n        el.appendChild(this.doc.createTextNode(tok.content));\n      }\n    }\n  }\n\n  /**\n   * Build a style element from an atomic style token.\n   *\n   * @param {Object} tok The token\n   * @returns {Element}\n   */\n  _buildStyle(tok) {\n    const el = this.doc.createElement(tok.tagName);\n\n    el.setAttribute('type', tok.type);\n\n    // Set attributes\n    utils.eachKey(tok.attrs, (name, value) => {\n      el.setAttribute(name, value);\n    });\n\n    return el;\n  }\n\n  /**\n   * Append a span to the stream. That span will act as a cursor\n   * (i.e. insertion point) for the element.\n   *\n   * @param {Object} el The element\n   * @param {string} which The type of proxy element\n   */\n  _insertCursor(el, which) {\n    this._writeImpl(`<span id=\"${which}\"/>`);\n\n    const cursor = this.doc.getElementById(which);\n\n    if (cursor) {\n      cursor.parentNode.replaceChild(el, cursor);\n    }\n  }\n\n  /**\n   * Called when a script is started.\n   *\n   * @param {Object} tok The token\n   * @private\n   */\n  _onScriptStart(tok) {\n    tok.outerWrites = this.writeQueue;\n    this.writeQueue = [];\n    this.scriptStack.unshift(tok);\n  }\n\n  /**\n   * Called when a script is done.\n   *\n   * @param {Object} tok The token\n   * @private\n   */\n  _onScriptDone(tok) {\n    // Pop script and check nesting.\n    if (tok !== this.scriptStack[0]) {\n      this.options.error({msg: 'Bad script nesting or script finished twice'});\n      return;\n    }\n\n    this.scriptStack.shift();\n\n    // Append outer writes to queue and process them.\n    this.write.apply(this, tok.outerWrites);\n\n    // Check for pending remote\n\n    // Assumption 2: if remote_script1 writes remote_script2 then\n    // the we notice remote_script1 finishes before remote_script2 starts.\n    // I think this is equivalent to assumption 1\n    if (!this.scriptStack.length && this.deferredRemote) {\n      this._onScriptStart(this.deferredRemote);\n      this.deferredRemote = null;\n    }\n  }\n\n  /**\n   * Build a script and insert it into the DOM.\n   * Done is called once script has executed.\n   *\n   * @param {Object} tok The token\n   * @param {Function} done The callback when complete\n   */\n  _writeScriptToken(tok, done) {\n    const el = this._buildScript(tok);\n    const asyncRelease = this._shouldRelease(el);\n    const afterAsync = this.options.afterAsync;\n\n    if (tok.src) {\n      // Fix for attribute \"SRC\" (capitalized). IE does not recognize it.\n      el.src = tok.src;\n      this._scriptLoadHandler(el, !asyncRelease ? () => {\n        done();\n        afterAsync();\n      } : afterAsync);\n    }\n\n    try {\n      this._insertCursor(el, PROXY_SCRIPT);\n      if (!el.src || asyncRelease) {\n        done();\n      }\n    } catch (e) {\n      this.options.error(e);\n      done();\n    }\n  }\n\n  /**\n   * Build a script element from an atomic script token.\n   *\n   * @param {Object} tok The token\n   * @returns {Element}\n   */\n  _buildScript(tok) {\n    const el = this.doc.createElement(tok.tagName);\n\n    // Set attributes\n    utils.eachKey(tok.attrs, (name, value) => {\n      el.setAttribute(name, value);\n    });\n\n    // Set content\n    if (tok.content) {\n      el.text = tok.content;\n    }\n\n    return el;\n  }\n\n  /**\n   * Setup the script load handler on an element.\n   *\n   * @param {Object} el The element\n   * @param {Function} done The callback\n   * @private\n   */\n  _scriptLoadHandler(el, done) {\n    function cleanup() {\n      el = el.onload = el.onreadystatechange = el.onerror = null;\n    }\n\n    const error = this.options.error;\n\n    function success() {\n      cleanup();\n      if (done != null) {\n        done();\n      }\n      done = null;\n    }\n\n    function failure(err) {\n      cleanup();\n      error(err);\n      if (done != null) {\n        done();\n      }\n      done = null;\n    }\n\n    function reattachEventListener(el, evt) {\n      const handler = el[`on${evt}`];\n      if (handler != null) {\n        el[`_on${evt}`] = handler;\n      }\n    }\n\n    reattachEventListener(el, 'load');\n    reattachEventListener(el, 'error');\n\n    Object.assign(el, {\n      onload() {\n        if (el._onload) {\n          try {\n            el._onload.apply(this, Array.prototype.slice.call(arguments, 0));\n          } catch (err) {\n            failure({msg: `onload handler failed ${err} @ ${el.src}`});\n          }\n        }\n        success();\n      },\n\n      onerror() {\n        if (el._onerror) {\n          try {\n            el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));\n          } catch (err) {\n            failure({msg: `onerror handler failed ${err} @ ${el.src}`});\n            return;\n          }\n        }\n        failure({msg: `remote script failed ${el.src}`});\n      },\n\n      onreadystatechange() {\n        if (/^(loaded|complete)$/.test(el.readyState)) {\n          success();\n        }\n      }\n    });\n  }\n\n  /**\n   * Determines whether to release.\n   *\n   * @param {Object} el The element\n   * @returns {boolean}\n   * @private\n   */\n  _shouldRelease(el) {\n    const isScript = (/^script$/i).test(el.nodeName);\n    return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/write-stream.js","/**\n * @file prescribe\n * @description Tiny, forgiving HTML parser\n * @version vundefined\n * @see {@link https://github.com/krux/prescribe/}\n * @license MIT\n * @author Derek Brans\n * @copyright 2016 Krux Digital, Inc\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Prescribe\"] = factory();\n\telse\n\t\troot[\"Prescribe\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _HtmlParser = __webpack_require__(1);\n\n\tvar _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tmodule.exports = _HtmlParser2['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _supports = __webpack_require__(2);\n\n\tvar supports = _interopRequireWildcard(_supports);\n\n\tvar _streamReaders = __webpack_require__(3);\n\n\tvar streamReaders = _interopRequireWildcard(_streamReaders);\n\n\tvar _fixedReadTokenFactory = __webpack_require__(6);\n\n\tvar _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);\n\n\tvar _utils = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Detection regular expressions.\n\t *\n\t * Order of detection matters: detection of one can only\n\t * succeed if detection of previous didn't\n\n\t * @type {Object}\n\t */\n\tvar detect = {\n\t  comment: /^<!--/,\n\t  endTag: /^<\\//,\n\t  atomicTag: /^<\\s*(script|style|noscript|iframe|textarea)[\\s\\/>]/i,\n\t  startTag: /^</,\n\t  chars: /^[^<]/\n\t};\n\n\t/**\n\t * HtmlParser provides the capability to parse HTML and return tokens\n\t * representing the tags and content.\n\t */\n\n\tvar HtmlParser = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} stream The initial parse stream contents.\n\t   * @param {Object} options The options\n\t   * @param {boolean} options.autoFix Set to true to automatically fix errors\n\t   */\n\t  function HtmlParser() {\n\t    var _this = this;\n\n\t    var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t    _classCallCheck(this, HtmlParser);\n\n\t    this.stream = stream;\n\n\t    var fix = false;\n\t    var fixedTokenOptions = {};\n\n\t    for (var key in supports) {\n\t      if (supports.hasOwnProperty(key)) {\n\t        if (options.autoFix) {\n\t          fixedTokenOptions[key + 'Fix'] = true; // !supports[key];\n\t        }\n\t        fix = fix || fixedTokenOptions[key + 'Fix'];\n\t      }\n\t    }\n\n\t    if (fix) {\n\t      this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t        return _this._readTokenImpl();\n\t      });\n\t      this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t        return _this._peekTokenImpl();\n\t      });\n\t    } else {\n\t      this._readToken = this._readTokenImpl;\n\t      this._peekToken = this._peekTokenImpl;\n\t    }\n\t  }\n\n\t  /**\n\t   * Appends the given string to the parse stream.\n\t   *\n\t   * @param {string} str The string to append\n\t   */\n\n\n\t  HtmlParser.prototype.append = function append(str) {\n\t    this.stream += str;\n\t  };\n\n\t  /**\n\t   * Prepends the given string to the parse stream.\n\t   *\n\t   * @param {string} str The string to prepend\n\t   */\n\n\n\t  HtmlParser.prototype.prepend = function prepend(str) {\n\t    this.stream = str + this.stream;\n\t  };\n\n\t  /**\n\t   * The implementation of the token reading.\n\t   *\n\t   * @private\n\t   * @returns {?Token}\n\t   */\n\n\n\t  HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {\n\t    var token = this._peekTokenImpl();\n\t    if (token) {\n\t      this.stream = this.stream.slice(token.length);\n\t      return token;\n\t    }\n\t  };\n\n\t  /**\n\t   * The implementation of token peeking.\n\t   *\n\t   * @returns {?Token}\n\t   */\n\n\n\t  HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {\n\t    for (var type in detect) {\n\t      if (detect.hasOwnProperty(type)) {\n\t        if (detect[type].test(this.stream)) {\n\t          var token = streamReaders[type](this.stream);\n\n\t          if (token) {\n\t            if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {\n\t              return null;\n\t            } else {\n\t              token.text = this.stream.substr(0, token.length);\n\t              return token;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * The public token peeking interface.  Delegates to the basic token peeking\n\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t   * options.\n\t   *\n\t   * @returns {object}\n\t   */\n\n\n\t  HtmlParser.prototype.peekToken = function peekToken() {\n\t    return this._peekToken();\n\t  };\n\n\t  /**\n\t   * The public token reading interface.  Delegates to the basic token reading\n\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t   * options.\n\t   *\n\t   * @returns {object}\n\t   */\n\n\n\t  HtmlParser.prototype.readToken = function readToken() {\n\t    return this._readToken();\n\t  };\n\n\t  /**\n\t   * Read tokens and hand to the given handlers.\n\t   *\n\t   * @param {Object} handlers The handlers to use for the different tokens.\n\t   */\n\n\n\t  HtmlParser.prototype.readTokens = function readTokens(handlers) {\n\t    var tok = void 0;\n\t    while (tok = this.readToken()) {\n\t      // continue until we get an explicit \"false\" return\n\t      if (handlers[tok.type] && handlers[tok.type](tok) === false) {\n\t        return;\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * Clears the parse stream.\n\t   *\n\t   * @returns {string} The contents of the parse stream before clearing.\n\t   */\n\n\n\t  HtmlParser.prototype.clear = function clear() {\n\t    var rest = this.stream;\n\t    this.stream = '';\n\t    return rest;\n\t  };\n\n\t  /**\n\t   * Returns the rest of the parse stream.\n\t   *\n\t   * @returns {string} The contents of the parse stream.\n\t   */\n\n\n\t  HtmlParser.prototype.rest = function rest() {\n\t    return this.stream;\n\t  };\n\n\t  return HtmlParser;\n\t}();\n\n\texports['default'] = HtmlParser;\n\n\n\tHtmlParser.tokenToString = function (tok) {\n\t  return tok.toString();\n\t};\n\n\tHtmlParser.escapeAttributes = function (attrs) {\n\t  var escapedAttrs = {};\n\n\t  for (var name in attrs) {\n\t    if (attrs.hasOwnProperty(name)) {\n\t      escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);\n\t    }\n\t  }\n\n\t  return escapedAttrs;\n\t};\n\n\tHtmlParser.supports = supports;\n\n\tfor (var key in supports) {\n\t  if (supports.hasOwnProperty(key)) {\n\t    HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;\n\t  }\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\tvar tagSoup = false;\n\tvar selfClose = false;\n\n\tvar work = window.document.createElement('div');\n\n\ttry {\n\t  var html = '<P><I></P></I>';\n\t  work.innerHTML = html;\n\t  exports.tagSoup = tagSoup = work.innerHTML !== html;\n\t} catch (e) {\n\t  exports.tagSoup = tagSoup = false;\n\t}\n\n\ttry {\n\t  work.innerHTML = '<P><i><P></P></i></P>';\n\t  exports.selfClose = selfClose = work.childNodes.length === 2;\n\t} catch (e) {\n\t  exports.selfClose = selfClose = false;\n\t}\n\n\twork = null;\n\n\texports.tagSoup = tagSoup;\n\texports.selfClose = selfClose;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports.comment = comment;\n\texports.chars = chars;\n\texports.startTag = startTag;\n\texports.atomicTag = atomicTag;\n\texports.endTag = endTag;\n\n\tvar _tokens = __webpack_require__(4);\n\n\t/**\n\t * Regular Expressions for parsing tags and attributes\n\t *\n\t * @type {Object}\n\t */\n\tvar REGEXES = {\n\t  startTag: /^<([\\-A-Za-z0-9_]+)((?:\\s+[\\w\\-]+(?:\\s*=?\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n\t  endTag: /^<\\/([\\-A-Za-z0-9_]+)[^>]*>/,\n\t  attr: /(?:([\\-A-Za-z0-9_]+)\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))|(?:([\\-A-Za-z0-9_]+)(\\s|$)+)/g,\n\t  fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i\n\t};\n\n\t/**\n\t * Reads a comment token\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {CommentToken}\n\t */\n\tfunction comment(stream) {\n\t  var index = stream.indexOf('-->');\n\t  if (index >= 0) {\n\t    return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);\n\t  }\n\t}\n\n\t/**\n\t * Reads non-tag characters.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {CharsToken}\n\t */\n\tfunction chars(stream) {\n\t  var index = stream.indexOf('<');\n\t  return new _tokens.CharsToken(index >= 0 ? index : stream.length);\n\t}\n\n\t/**\n\t * Reads start tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {StartTagToken}\n\t */\n\tfunction startTag(stream) {\n\t  var endTagIndex = stream.indexOf('>');\n\t  if (endTagIndex !== -1) {\n\t    var match = stream.match(REGEXES.startTag);\n\t    if (match) {\n\t      var _ret = function () {\n\t        var attrs = {};\n\t        var booleanAttrs = {};\n\t        var rest = match[2];\n\n\t        match[2].replace(REGEXES.attr, function (match, name) {\n\t          if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {\n\t            attrs[name] = '';\n\t          } else if (arguments[5]) {\n\t            attrs[arguments[5]] = '';\n\t            booleanAttrs[arguments[5]] = true;\n\t          } else {\n\t            attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';\n\t          }\n\n\t          rest = rest.replace(match, '');\n\t        });\n\n\t        return {\n\t          v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''))\n\t        };\n\t      }();\n\n\t      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Reads atomic tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {AtomicTagToken}\n\t */\n\tfunction atomicTag(stream) {\n\t  var start = startTag(stream);\n\t  if (start) {\n\t    var rest = stream.slice(start.length);\n\t    // for optimization, we check first just for the end tag\n\t    if (rest.match(new RegExp('<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'))) {\n\t      // capturing the content is inefficient, so we do it inside the if\n\t      var match = rest.match(new RegExp('([\\\\s\\\\S]*?)<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'));\n\t      if (match) {\n\t        return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Reads an end tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {EndTagToken}\n\t */\n\tfunction endTag(stream) {\n\t  var match = stream.match(REGEXES.endTag);\n\t  if (match) {\n\t    return new _tokens.EndTagToken(match[1], match[0].length);\n\t  }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;\n\n\tvar _utils = __webpack_require__(5);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Token is a base class for all token types parsed.  Note we don't actually\n\t * use intheritance due to IE8's non-existent ES5 support.\n\t */\n\tvar Token =\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} type The type of the Token.\n\t * @param {Number} length The length of the Token text.\n\t */\n\texports.Token = function Token(type, length) {\n\t  _classCallCheck(this, Token);\n\n\t  this.type = type;\n\t  this.length = length;\n\t  this.text = '';\n\t};\n\n\t/**\n\t * CommentToken represents comment tags.\n\t */\n\n\n\tvar CommentToken = exports.CommentToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} content The content of the comment\n\t   * @param {Number} length The length of the Token text.\n\t   */\n\t  function CommentToken(content, length) {\n\t    _classCallCheck(this, CommentToken);\n\n\t    this.type = 'comment';\n\t    this.length = length || (content ? content.length : 0);\n\t    this.text = '';\n\t    this.content = content;\n\t  }\n\n\t  CommentToken.prototype.toString = function toString() {\n\t    return '<!--' + this.content;\n\t  };\n\n\t  return CommentToken;\n\t}();\n\n\t/**\n\t * CharsToken represents non-tag characters.\n\t */\n\n\n\tvar CharsToken = exports.CharsToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {Number} length The length of the Token text.\n\t   */\n\t  function CharsToken(length) {\n\t    _classCallCheck(this, CharsToken);\n\n\t    this.type = 'chars';\n\t    this.length = length;\n\t    this.text = '';\n\t  }\n\n\t  CharsToken.prototype.toString = function toString() {\n\t    return this.text;\n\t  };\n\n\t  return CharsToken;\n\t}();\n\n\t/**\n\t * TagToken is a base class for all tag-based Tokens.\n\t */\n\n\n\tvar TagToken = exports.TagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} type The type of the token.\n\t   * @param {string} tagName The tag name.\n\t   * @param {Number} length The length of the Token text.\n\t   * @param {Object} attrs The dictionary of attributes and values\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   */\n\t  function TagToken(type, tagName, length, attrs, booleanAttrs) {\n\t    _classCallCheck(this, TagToken);\n\n\t    this.type = type;\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.unary = false;\n\t    this.html5Unary = false;\n\t  }\n\n\t  /**\n\t   * Formats the given token tag.\n\t   *\n\t   * @param {TagToken} tok The TagToken to format.\n\t   * @param {?string} [content=null] The content of the token.\n\t   * @returns {string} The formatted tag.\n\t   */\n\n\n\t  TagToken.formatTag = function formatTag(tok) {\n\t    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t    var str = '<' + tok.tagName;\n\t    for (var key in tok.attrs) {\n\t      if (tok.attrs.hasOwnProperty(key)) {\n\t        str += ' ' + key;\n\n\t        var val = tok.attrs[key];\n\t        if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {\n\t          str += '=\"' + (0, _utils.escapeQuotes)(val) + '\"';\n\t        }\n\t      }\n\t    }\n\n\t    if (tok.rest) {\n\t      str += ' ' + tok.rest;\n\t    }\n\n\t    if (tok.unary && !tok.html5Unary) {\n\t      str += '/>';\n\t    } else {\n\t      str += '>';\n\t    }\n\n\t    if (content !== undefined && content !== null) {\n\t      str += content + '</' + tok.tagName + '>';\n\t    }\n\n\t    return str;\n\t  };\n\n\t  return TagToken;\n\t}();\n\n\t/**\n\t * StartTagToken represents a start token.\n\t */\n\n\n\tvar StartTagToken = exports.StartTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The tag name.\n\t   * @param {Number} length The length of the Token text\n\t   * @param {Object} attrs The dictionary of attributes and values\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   * @param {boolean} unary True if the tag is a unary tag\n\t   * @param {string} rest The rest of the content.\n\t   */\n\t  function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {\n\t    _classCallCheck(this, StartTagToken);\n\n\t    this.type = 'startTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.html5Unary = false;\n\t    this.unary = unary;\n\t    this.rest = rest;\n\t  }\n\n\t  StartTagToken.prototype.toString = function toString() {\n\t    return TagToken.formatTag(this);\n\t  };\n\n\t  return StartTagToken;\n\t}();\n\n\t/**\n\t * AtomicTagToken represents an atomic tag.\n\t */\n\n\n\tvar AtomicTagToken = exports.AtomicTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The name of the tag.\n\t   * @param {Number} length The length of the tag text.\n\t   * @param {Object} attrs The attributes.\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   * @param {string} content The content of the tag.\n\t   */\n\t  function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {\n\t    _classCallCheck(this, AtomicTagToken);\n\n\t    this.type = 'atomicTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.unary = false;\n\t    this.html5Unary = false;\n\t    this.content = content;\n\t  }\n\n\t  AtomicTagToken.prototype.toString = function toString() {\n\t    return TagToken.formatTag(this, this.content);\n\t  };\n\n\t  return AtomicTagToken;\n\t}();\n\n\t/**\n\t * EndTagToken represents an end tag.\n\t */\n\n\n\tvar EndTagToken = exports.EndTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The name of the tag.\n\t   * @param {Number} length The length of the tag text.\n\t   */\n\t  function EndTagToken(tagName, length) {\n\t    _classCallCheck(this, EndTagToken);\n\n\t    this.type = 'endTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t  }\n\n\t  EndTagToken.prototype.toString = function toString() {\n\t    return '</' + this.tagName + '>';\n\t  };\n\n\t  return EndTagToken;\n\t}();\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.escapeQuotes = escapeQuotes;\n\n\t/**\n\t * Escape quotes in the given value.\n\t *\n\t * @param {string} value The value to escape.\n\t * @param {string} [defaultValue=''] The default value to return if value is falsy.\n\t * @returns {string}\n\t */\n\tfunction escapeQuotes(value) {\n\t  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\t  // There's no lookback in JS, so /(^|[^\\\\])\"/ only matches the first of two `\"`s.\n\t  // Instead, just match anything before a double-quote and escape if it's not already escaped.\n\t  return !value ? defaultValue : value.replace(/([^\"]*)\"/g, function (_, prefix) {\n\t    return (/\\\\/.test(prefix) ? prefix + '\"' : prefix + '\\\\\"'\n\t    );\n\t  });\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = fixedReadTokenFactory;\n\t/**\n\t * Empty Elements - HTML 4.01\n\t *\n\t * @type {RegExp}\n\t */\n\tvar EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;\n\n\t/**\n\t * Elements that you can intentionally leave open (and which close themselves)\n\t *\n\t * @type {RegExp}\n\t */\n\tvar CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;\n\n\t/**\n\t * Corrects a token.\n\t *\n\t * @param {Token} tok The token to correct\n\t * @returns {Token} The corrected token\n\t */\n\tfunction correct(tok) {\n\t  if (tok && tok.type === 'startTag') {\n\t    tok.unary = EMPTY.test(tok.tagName) || tok.unary;\n\t    tok.html5Unary = !/\\/>$/.test(tok.text);\n\t  }\n\t  return tok;\n\t}\n\n\t/**\n\t * Peeks at the next token in the parser.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t * @returns {Token} The next token\n\t */\n\tfunction peekToken(parser, readTokenImpl) {\n\t  var tmp = parser.stream;\n\t  var tok = correct(readTokenImpl());\n\t  parser.stream = tmp;\n\t  return tok;\n\t}\n\n\t/**\n\t * Closes the last token.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Array<Token>} stack The stack\n\t */\n\tfunction closeLast(parser, stack) {\n\t  var tok = stack.pop();\n\n\t  // prepend close tag to stream.\n\t  parser.prepend('</' + tok.tagName + '>');\n\t}\n\n\t/**\n\t * Create a new token stack.\n\t *\n\t * @returns {Array<Token>}\n\t */\n\tfunction newStack() {\n\t  var stack = [];\n\n\t  stack.last = function () {\n\t    return this[this.length - 1];\n\t  };\n\n\t  stack.lastTagNameEq = function (tagName) {\n\t    var last = this.last();\n\t    return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();\n\t  };\n\n\t  stack.containsTagName = function (tagName) {\n\t    for (var i = 0, tok; tok = this[i]; i++) {\n\t      if (tok.tagName === tagName) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  };\n\n\t  return stack;\n\t}\n\n\t/**\n\t * Return a readToken implementation that fixes input.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Object} options Options for fixing\n\t * @param {boolean} options.tagSoupFix True to fix tag soup scenarios\n\t * @param {boolean} options.selfCloseFix True to fix self-closing tags\n\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t * @returns {Function}\n\t */\n\tfunction fixedReadTokenFactory(parser, options, readTokenImpl) {\n\t  var stack = newStack();\n\n\t  var handlers = {\n\t    startTag: function startTag(tok) {\n\t      var tagName = tok.tagName;\n\n\t      if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {\n\t        parser.prepend('<TBODY>');\n\t        prepareNextToken();\n\t      } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {\n\t        if (stack.lastTagNameEq(tagName)) {\n\t          closeLast(parser, stack);\n\t        } else {\n\t          parser.prepend('</' + tok.tagName + '>');\n\t          prepareNextToken();\n\t        }\n\t      } else if (!tok.unary) {\n\t        stack.push(tok);\n\t      }\n\t    },\n\t    endTag: function endTag(tok) {\n\t      var last = stack.last();\n\t      if (last) {\n\t        if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {\n\t          // cleanup tag soup\n\t          closeLast(parser, stack);\n\t        } else {\n\t          stack.pop();\n\t        }\n\t      } else if (options.tagSoupFix) {\n\t        // cleanup tag soup part 2: skip this token\n\t        readTokenImpl();\n\t        prepareNextToken();\n\t      }\n\t    }\n\t  };\n\n\t  function prepareNextToken() {\n\t    var tok = peekToken(parser, readTokenImpl);\n\t    if (tok && handlers[tok.type]) {\n\t      handlers[tok.type](tok);\n\t    }\n\t  }\n\n\t  return function fixedReadToken() {\n\t    prepareNextToken();\n\t    return correct(readTokenImpl());\n\t  };\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prescribe/dist/prescribe.js\n// module id = 3\n// module chunks = 0","/**\n * Determine if the thing is not undefined and not null.\n *\n * @param {*} thing The thing to test\n * @returns {boolean} True if the thing is not undefined and not null.\n */\nexport function existy(thing) {\n  return thing !== void 0 && thing !== null;\n}\n\n/**\n * Is this a function?\n *\n * @param {*} x The variable to test\n * @returns {boolean} True if the variable is a function\n */\nexport function isFunction(x) {\n  return 'function' === typeof x;\n}\n\n/**\n * Loop over each item in an array-like value.\n *\n * @param {Array<*>} arr The array to loop over\n * @param {Function} fn The function to call\n * @param {?Object} target The object to bind to the function\n */\nexport function each(arr, fn, target) {\n  let i;\n  const len = (arr && arr.length) || 0;\n  for (i = 0; i < len; i++) {\n    fn.call(target, arr[i], i);\n  }\n}\n\n/**\n * Loop over each key/value pair in a hash.\n *\n * @param {Object} obj The object\n * @param {Function} fn The function to call\n * @param {?Object} target The object to bind to the function\n */\nexport function eachKey(obj, fn, target) {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(target, key, obj[key]);\n    }\n  }\n}\n\n/**\n * Set default options where some option was not specified.\n *\n * @param {Object} options The destination\n * @param {Object} _defaults The defaults\n * @returns {Object}\n */\nexport function defaults(options, _defaults) {\n  options = options || {};\n  eachKey(_defaults, function(key, val) {\n    if (!existy(options[key])) {\n      options[key] = val;\n    }\n  });\n  return options;\n}\n\n/**\n * Convert value (e.g., a NodeList) to an array.\n *\n * @param {*} obj The object\n * @returns {Array<*>}\n */\nexport function toArray(obj) {\n  try {\n    return Array.prototype.slice.call(obj);\n  } catch (e) {\n    const ret = [];\n    each(obj, function(val) {\n      ret.push(val);\n    });\n    return ret;\n  }\n}\n\n/**\n * Get the last item in an array\n *\n * @param {Array<*>} array The array\n * @returns {*} The last item in the array\n */\nexport function last(array) {\n  return array[array.length - 1];\n}\n\n/**\n * Test if token is a script tag.\n *\n * @param {Object} tok The token\n * @param {String} tag The tag name\n * @returns {boolean} True if the token is a script tag\n */\nexport function isTag(tok, tag) {\n  return !tok ||\n    !(tok.type === 'startTag' || tok.type === 'atomicTag') ||\n    !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);\n}\n\n/**\n * Test if token is a script tag.\n *\n * @param {Object} tok The token\n * @returns {boolean} True if the token is a script tag\n */\nexport function isScript(tok) {\n  return isTag(tok, 'script');\n}\n\n/**\n * Test if token is a style tag.\n *\n * @param {Object} tok The token\n * @returns {boolean} True if the token is a style tag\n */\nexport function isStyle(tok) {\n  return isTag(tok, 'style');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""},"metadata":{},"sourceType":"module"}